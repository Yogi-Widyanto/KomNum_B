{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Error in Numerical Computations \u00b6 Nama : Yogi Widyanto NIM : 180411100049 Materi \u00b6 Error atau Galat \u00b6 Error / Galat merupakan perbedaan antara hasil penyelesaian suatu model matematik secara numeric dengan penyelesaian secara analitis. Kesalahan yang terjadi sangatlah penting, karena kesalahan dalam pemakaian algoritma pendekatan akan menyebabkan nilai kesalahan yang besar. Sehingga pendekatan metode numerik selalu membahas tingkat kesalahan dan tingkat kecepatan proses yang akan terjadi. Round of Error \u00b6 Perhitungan dengan metode numerik hampir selalu menggunakan bilangan riil. Masalah timbul bila komputasi numerik dikerjakan oleh mesin (dalam hal ini komputer) karena semua bilangan riil tidak dapat disajikan secara tepat di dalam komputer. Sebagai contoh 1/6 = 0.166666666\u2026 Truncation Error \u00b6 Kesalahan pemotongan terjadi ketika suatu rumus komputasi disederhanakan dengan cara membuang suku yang berderajat tinggi.Metode numerik menggunakan pendekatan untuk menyelesaikan masalah. Kesalahan yang diperkenalkan oleh aproksimasi adalah kesalahan pemotongan. Rumus Truncation errors : Deret Maclaurin \u00b6 Deret Maclaurin sangat berguna dalam komputasi numerik dalam menghitung nilai - nilai fungsi yang susah dihitung secara manual. Contoh sin(x), cos(x), e^x berikut algoritma mclaurin Deret MacLaurin biasa disebut sebagai deret Taylor baku, kerena deret maclaurin merupakan standar atau dasar yang berlaku dengan a=0. Atau persamaan Deret MacLaurin diatas dapat ditulis seperti berikut $$ f(x) = \\sum \\limits_{i=0}^{n} {f^i(0)x^i \\over i!} $$ Hasil Code \u00b6 Berikut implementasi deret maclaurin \u00b6 import math print ( \"Soal : e^(3x)\" ) print ( \" \" ) x = 1 var = 1 fa = 1 kondisi = True while kondisi == True : f = (( 3 ** var ) * ( x ** var )) / math . factorial ( var ) fnew = fa + f test = fnew - fa print ( \"s\" , var , \"=\" , fa ) print ( \"s\" , var + 1 , \"=\" , fnew ) print ( \"selisih : \" , test ) print ( \"--------------------------------------------------\" ) if test <= 0.0001 : break else : fa += f var += 1 print ( \"\" ) print ( 'total iterasi : ' , var ) print ( 'untuk x =' , x ) hasil dari program diatas Soal : e^(3x) s 1 = 1 s 2 = 4.0 selisih : 3.0 -------------------------------------------------- s 2 = 4.0 s 3 = 8.5 selisih : 4.5 -------------------------------------------------- s 3 = 8.5 s 4 = 13.0 selisih : 4.5 -------------------------------------------------- s 4 = 13.0 s 5 = 16.375 selisih : 3.375 -------------------------------------------------- s 5 = 16.375 s 6 = 18.4 selisih : 2.0249999999999986 -------------------------------------------------- s 6 = 18.4 s 7 = 19.412499999999998 selisih : 1.0124999999999993 -------------------------------------------------- s 7 = 19.412499999999998 s 8 = 19.846428571428568 selisih : 0.4339285714285701 -------------------------------------------------- s 8 = 19.846428571428568 s 9 = 20.009151785714284 selisih : 0.162723214285716 -------------------------------------------------- s 9 = 20.009151785714284 s 10 = 20.063392857142855 selisih : 0.05424107142857082 -------------------------------------------------- s 10 = 20.063392857142855 s 11 = 20.079665178571425 selisih : 0.016272321428569825 -------------------------------------------------- s 11 = 20.079665178571425 s 12 = 20.08410308441558 selisih : 0.004437905844156376 -------------------------------------------------- s 12 = 20.08410308441558 s 13 = 20.08521256087662 selisih : 0.001109476461039094 -------------------------------------------------- s 13 = 20.08521256087662 s 14 = 20.08546859390609 selisih : 0.0002560330294691937 -------------------------------------------------- s 14 = 20.08546859390609 s 15 = 20.08552345812669 selisih : 5.4864220601302804e-05 -------------------------------------------------- total iterasi : 14 untuk x = 1 Penjelasan \u00b6 import math # import module math print ( \"Soal : e^(3x)\" ) print ( \" \" ) x = 1 # nilai x var = 1 # untuk jumlah iterasi dan juga pangkat fa = 1 # nilai f awal kondisi = True # kondisi awal untuk looping while kondisi == True : f = (( 3 ** var ) * ( x ** var )) / math . factorial ( var ) # f=3^var*(x^var)/(var!) atau turunanya fnew = fa + f # fnew untuk menjumlahkan fa dengan f selanjutnya test = fnew - fa # mengetahui selisih print ( \"s\" , var , \"=\" , fa ) print ( \"s\" , var + 1 , \"=\" , fnew ) print ( \"selisih : \" , test ) print ( \"--------------------------------------------------\" ) if test <= 0.0001 : # jika selisih <= 0.0001 maka break break else : fa += f # jika tidak fawal diganti f var += 1 # var ditambah 1 print ( \"\" ) print ( 'total iterasi : ' , var ) print ( 'untuk x =' , x ) MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"Error in Numerical"},{"location":"#error-in-numerical-computations","text":"Nama : Yogi Widyanto NIM : 180411100049","title":"Error in Numerical Computations"},{"location":"#materi","text":"","title":"Materi"},{"location":"#error-atau-galat","text":"Error / Galat merupakan perbedaan antara hasil penyelesaian suatu model matematik secara numeric dengan penyelesaian secara analitis. Kesalahan yang terjadi sangatlah penting, karena kesalahan dalam pemakaian algoritma pendekatan akan menyebabkan nilai kesalahan yang besar. Sehingga pendekatan metode numerik selalu membahas tingkat kesalahan dan tingkat kecepatan proses yang akan terjadi.","title":"Error atau Galat"},{"location":"#round-of-error","text":"Perhitungan dengan metode numerik hampir selalu menggunakan bilangan riil. Masalah timbul bila komputasi numerik dikerjakan oleh mesin (dalam hal ini komputer) karena semua bilangan riil tidak dapat disajikan secara tepat di dalam komputer. Sebagai contoh 1/6 = 0.166666666\u2026","title":"Round of Error"},{"location":"#truncation-error","text":"Kesalahan pemotongan terjadi ketika suatu rumus komputasi disederhanakan dengan cara membuang suku yang berderajat tinggi.Metode numerik menggunakan pendekatan untuk menyelesaikan masalah. Kesalahan yang diperkenalkan oleh aproksimasi adalah kesalahan pemotongan. Rumus Truncation errors :","title":"Truncation Error"},{"location":"#deret-maclaurin","text":"Deret Maclaurin sangat berguna dalam komputasi numerik dalam menghitung nilai - nilai fungsi yang susah dihitung secara manual. Contoh sin(x), cos(x), e^x berikut algoritma mclaurin Deret MacLaurin biasa disebut sebagai deret Taylor baku, kerena deret maclaurin merupakan standar atau dasar yang berlaku dengan a=0. Atau persamaan Deret MacLaurin diatas dapat ditulis seperti berikut $$ f(x) = \\sum \\limits_{i=0}^{n} {f^i(0)x^i \\over i!} $$","title":"Deret Maclaurin"},{"location":"#hasil-code","text":"","title":"Hasil Code"},{"location":"#berikut-implementasi-deret-maclaurin","text":"import math print ( \"Soal : e^(3x)\" ) print ( \" \" ) x = 1 var = 1 fa = 1 kondisi = True while kondisi == True : f = (( 3 ** var ) * ( x ** var )) / math . factorial ( var ) fnew = fa + f test = fnew - fa print ( \"s\" , var , \"=\" , fa ) print ( \"s\" , var + 1 , \"=\" , fnew ) print ( \"selisih : \" , test ) print ( \"--------------------------------------------------\" ) if test <= 0.0001 : break else : fa += f var += 1 print ( \"\" ) print ( 'total iterasi : ' , var ) print ( 'untuk x =' , x ) hasil dari program diatas Soal : e^(3x) s 1 = 1 s 2 = 4.0 selisih : 3.0 -------------------------------------------------- s 2 = 4.0 s 3 = 8.5 selisih : 4.5 -------------------------------------------------- s 3 = 8.5 s 4 = 13.0 selisih : 4.5 -------------------------------------------------- s 4 = 13.0 s 5 = 16.375 selisih : 3.375 -------------------------------------------------- s 5 = 16.375 s 6 = 18.4 selisih : 2.0249999999999986 -------------------------------------------------- s 6 = 18.4 s 7 = 19.412499999999998 selisih : 1.0124999999999993 -------------------------------------------------- s 7 = 19.412499999999998 s 8 = 19.846428571428568 selisih : 0.4339285714285701 -------------------------------------------------- s 8 = 19.846428571428568 s 9 = 20.009151785714284 selisih : 0.162723214285716 -------------------------------------------------- s 9 = 20.009151785714284 s 10 = 20.063392857142855 selisih : 0.05424107142857082 -------------------------------------------------- s 10 = 20.063392857142855 s 11 = 20.079665178571425 selisih : 0.016272321428569825 -------------------------------------------------- s 11 = 20.079665178571425 s 12 = 20.08410308441558 selisih : 0.004437905844156376 -------------------------------------------------- s 12 = 20.08410308441558 s 13 = 20.08521256087662 selisih : 0.001109476461039094 -------------------------------------------------- s 13 = 20.08521256087662 s 14 = 20.08546859390609 selisih : 0.0002560330294691937 -------------------------------------------------- s 14 = 20.08546859390609 s 15 = 20.08552345812669 selisih : 5.4864220601302804e-05 -------------------------------------------------- total iterasi : 14 untuk x = 1","title":"Berikut implementasi deret maclaurin"},{"location":"#penjelasan","text":"import math # import module math print ( \"Soal : e^(3x)\" ) print ( \" \" ) x = 1 # nilai x var = 1 # untuk jumlah iterasi dan juga pangkat fa = 1 # nilai f awal kondisi = True # kondisi awal untuk looping while kondisi == True : f = (( 3 ** var ) * ( x ** var )) / math . factorial ( var ) # f=3^var*(x^var)/(var!) atau turunanya fnew = fa + f # fnew untuk menjumlahkan fa dengan f selanjutnya test = fnew - fa # mengetahui selisih print ( \"s\" , var , \"=\" , fa ) print ( \"s\" , var + 1 , \"=\" , fnew ) print ( \"selisih : \" , test ) print ( \"--------------------------------------------------\" ) if test <= 0.0001 : # jika selisih <= 0.0001 maka break break else : fa += f # jika tidak fawal diganti f var += 1 # var ditambah 1 print ( \"\" ) print ( 'total iterasi : ' , var ) print ( 'untuk x =' , x ) MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"Penjelasan"},{"location":"pers_linier/","text":"Numerical Solution of System of Linear Algebraic Equations \u00b6 Eliminasi Gauss Jordan \u00b6 Eliminasi Gauss adalah suatu metode untuk mengoperasikan nilai-nilai di dalam matriks sehingga menjadi matriks yang lebih sederhana lagi. Dengan melakukan operasi baris sehingga matriks tersebut menjadi matriks yang baris. Ini dapat digunakan sebagai salah satu metode penyelesaian persamaan linear dengan menggunakan matriks. Caranya dengan mengubah persamaan linear tersebut ke dalam matriks teraugmentasi dan mengoperasikannya. Setelah menjadi matriks baris, lakukan substitusi balik untuk mendapatkan nilai dari variabel-variabel tersebut. Metode Eliminasi Gauss Jordan merupakan pengembangan metode eliminasi gauss, hanya saja augmented matrik , pada sebelah kiri dirubah menjadi matrik diagonal. Algoritma Gauss Jordan \u00b6 Listing Program \u00b6 import numpy as np #Definisi Matrix A = [] B = [] n = int ( input ( \"Masukkan ukuran Matrix: \" )) for i in range ( n ): baris = [] for i in range ( n ): a = int ( input ( \"Masukkan Nilai: \" )) baris . append ( a ) A . append ( baris ) for i in range ( n ): h = int ( input ( \"Masukkan Hasil: \" )) B . append ( h ) Matrix = np . array ( A , float ) Hasil = np . array ( B , float ) n = len ( Matrix ) #Eliminasi Gauss for k in range ( 0 , n - 1 ): for i in range ( k + 1 , n ): if Matrix [ i , k ] != 0 : lam = Matrix [ i , k ] / Matrix [ k , k ] Matrix [ i , k : n ] = Matrix [ i , k : n ] - ( Matrix [ k , k : n ] * lam ) Hasil [ i ] = Hasil [ i ] - ( Hasil [ k ] * lam ) print ( \"Matrix A : \" , ' \\n ' , Matrix ) #Subtitution x = np . zeros ( n , float ) for m in range ( n - 1 , - 1 , - 1 ): x [ m ] = ( Hasil [ m ] - np . dot ( Matrix [ m , m + 1 : n ], x [ m + 1 : n ])) / Matrix [ m , m ] print ( 'Nilai X ' , m + 1 , '=' , x [ m ]) Output: Masukkan ukuran Matrix: 3 Masukkan Nilai: 2 Masukkan Nilai: -2 Masukkan Nilai: 5 Masukkan Nilai: 1 Masukkan Nilai: 5 Masukkan Nilai: 2 Masukkan Nilai: 4 Masukkan Nilai: 5 Masukkan Nilai: 2 Masukkan Hasil: 12 Masukkan Hasil: 3 Masukkan Hasil: -4 Matrix A : [[ 2. -2. 5. ] [ 0. 6. -0.5 ] [ 0. 0. -7.25]] Nilai X 3 = 3.2413793103448274 Nilai X 2 = -0.2298850574712644 Nilai X 1 = -2.333333333333332 jadi panjang Matrix yang dibuat dalam Program Diatas adalah 3 variabel. |2 -2 5| |12| |1 5 2|=| 3 | |4 5 2| |-4| pivot yang dibentuk adalah a1.1,a2.2,dan a3.3 sehingga semua angka yang ada dibawah pivot akan dikonversikan menjadi nol sesuai hasil program dan hasil dari persamaan diatas menghasilkan x1=-2.333333333, x2=-0.22988505 dan x3=3.2413793 Eliminasi Gauss Jacobi \u00b6 Metode Iterasi Jacobi merupakan salah satu bidang analisis numerik yang digunakan untuk menyelesaikan permasalahan Persamaan Linier dan sering dijumpai dalam berbagai disiplin ilmu. Metode Iterasi Jacobi merupakan salah satu metode tak langsung, yaitu bermula dari suatu hampiran penyelesaian awal dan kemudian berusaha memperbaiki hampiran dalam tak berhingga namun langkah konvergen. Metode Iterasi Jacobi ini digunakan untuk menyelesaikan persamaan Linier berukuran besar dan proporsi koefisien nolnya besar. Metode ini ditemukan oleh Matematikawan yang berasal dari Jerman,Carl,Gustav,Jacobi. Penemuan ini diperkirakan pada tahun 1800-an. Listing Program \u00b6 from pprint import pprint from numpy import array , zeros , diag , diagflat , dot import numpy as np def jacobi ( A , b , N = 25 , x = None ): #Membuat iniial guess if x is None : x = zeros ( len ( A [ 0 ])) #Membuat vektor dari elemen matrix A D = diag ( A ) R = A - diagflat ( D ) #Iterasi for i in range ( N ): x = ( b - dot ( R , x )) / D return x Mat1 = [] Mat2 = [] n = int ( input ( \"Masukkan ukuran Matrix: \" )) for i in range ( n ): baris = [] for i in range ( n ): a = int ( input ( \"Masukkan Nilai: \" )) baris . append ( a ) Mat1 . append ( baris ) for i in range ( n ): h = int ( input ( \"Masukkan Hasil: \" )) Mat2 . append ( h ) A = array ( Mat1 , float ) b = array ( Mat2 , float ) x = len ( Mat1 ) guess = np . zeros ( x , float ) sol = jacobi ( A , b , N = 25 , x = guess ) print ( \"A:\" ) pprint ( A ) print ( \"b:\" ) pprint ( b ) print ( \"x:\" ) pprint ( sol ) Output: Masukkan ukuran Matrix: 3 Masukkan Nilai: 3 Masukkan Nilai: 1 Masukkan Nilai: -1 Masukkan Nilai: 4 Masukkan Nilai: 7 Masukkan Nilai: -3 Masukkan Nilai: 2 Masukkan Nilai: -2 Masukkan Nilai: 5 Masukkan Hasil: 5 Masukkan Hasil: 20 Masukkan Hasil: 10 A: array([[ 3., 1., -1.], [ 4., 7., -3.], [ 2., -2., 5.]]) b: array([ 5., 20., 10.]) x: array([1.50602413, 3.13253016, 2.6506024 ]) Program Gauss Seidel \u00b6 Listing Program \u00b6 def seidel ( a , x , b ): #Mencari Panjang Matrix n = len ( a ) for j in range ( 0 , n ): d = b [ j ] #Menghitung xi, yi, zi for i in range ( 0 , n ): if ( j != i ): d -= a [ j ][ i ] * x [ i ] x [ j ] = d / a [ j ][ j ] #Solusi return x m = int ( input ( \"Masukkan Panjang Matrix: \" )) a = [] b = [] for k in range ( m ): mat1 = [] for i in range ( m ): l = float ( input ( \"Masukkan a\" + str ( k + 1 ) + \",\" + str ( i + 1 ) + \": \" )) mat1 . append ( l ) h = float ( input ( \"Masukkan Hasil: \" )) b . append ( h ) a . append ( mat1 ) n = 3 x = [ 0 , 0 , 0 ] print ( x ) for i in range ( 0 , 100 ): x = seidel ( a , x , b ) print ( x ) Output: Masukkan Panjang Matrix: 3 Masukkan a1,1: 4 Masukkan a1,2: -1 Masukkan a1,3: 1 Masukkan Hasil: 7 Masukkan a2,1: 4 Masukkan a2,2: -8 Masukkan a2,3: 1 Masukkan Hasil: -21 Masukkan a3,1: -2 Masukkan a3,2: 1 Masukkan a3,3: 5 Masukkan Hasil: 15 [0, 0, 0] [1.75, 3.5, 3.0] [1.875, 3.9375, 2.9625] [1.99375, 3.9921875, 2.9990625] [1.99828125, 3.9990234375, 2.9995078125] [1.99987890625, 3.9998779296875, 2.9999759765625003] [1.99997548828125, 3.9999847412109375, 2.999993247070312] [1.9999978735351562, 3.9999980926513667, 2.999999530883789] [1.9999996404418945, 3.9999997615814205, 2.9999999038604734] [1.9999999644302369, 3.9999999701976776, 2.9999999917325595] [1.9999999946162794, 3.9999999962747097, 2.99999999859157] [1.9999999994207849, 3.9999999995343387, 2.9999999998614464] [1.9999999999182232, 3.999999999941793, 2.999999999978931] [1.9999999999907154, 3.999999999992724, 2.9999999999977414] [1.9999999999987457, 3.9999999999990905, 2.9999999999996803] [1.9999999999998526, 3.9999999999998863, 2.9999999999999636] [1.9999999999999807, 3.999999999999986, 2.999999999999995] [1.9999999999999978, 3.9999999999999987, 2.9999999999999996] [1.9999999999999996, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] Dari soal diatas persamaan yang dipilih adalah 4x-y+z=7, 4x-8y+z=-21 dan -2x+y+5z=15. Iterasi yang digunakan sebanyak 100 iterasi sehingga dapat menghasilkan x=2,y=4 dan z=3.","title":"Metode Numeric untuk Persamaan Linier"},{"location":"pers_linier/#numerical-solution-of-system-of-linear-algebraic-equations","text":"","title":"Numerical Solution of System of Linear Algebraic Equations"},{"location":"pers_linier/#eliminasi-gauss-jordan","text":"Eliminasi Gauss adalah suatu metode untuk mengoperasikan nilai-nilai di dalam matriks sehingga menjadi matriks yang lebih sederhana lagi. Dengan melakukan operasi baris sehingga matriks tersebut menjadi matriks yang baris. Ini dapat digunakan sebagai salah satu metode penyelesaian persamaan linear dengan menggunakan matriks. Caranya dengan mengubah persamaan linear tersebut ke dalam matriks teraugmentasi dan mengoperasikannya. Setelah menjadi matriks baris, lakukan substitusi balik untuk mendapatkan nilai dari variabel-variabel tersebut. Metode Eliminasi Gauss Jordan merupakan pengembangan metode eliminasi gauss, hanya saja augmented matrik , pada sebelah kiri dirubah menjadi matrik diagonal.","title":"Eliminasi Gauss Jordan"},{"location":"pers_linier/#algoritma-gauss-jordan","text":"","title":"Algoritma Gauss Jordan"},{"location":"pers_linier/#listing-program","text":"import numpy as np #Definisi Matrix A = [] B = [] n = int ( input ( \"Masukkan ukuran Matrix: \" )) for i in range ( n ): baris = [] for i in range ( n ): a = int ( input ( \"Masukkan Nilai: \" )) baris . append ( a ) A . append ( baris ) for i in range ( n ): h = int ( input ( \"Masukkan Hasil: \" )) B . append ( h ) Matrix = np . array ( A , float ) Hasil = np . array ( B , float ) n = len ( Matrix ) #Eliminasi Gauss for k in range ( 0 , n - 1 ): for i in range ( k + 1 , n ): if Matrix [ i , k ] != 0 : lam = Matrix [ i , k ] / Matrix [ k , k ] Matrix [ i , k : n ] = Matrix [ i , k : n ] - ( Matrix [ k , k : n ] * lam ) Hasil [ i ] = Hasil [ i ] - ( Hasil [ k ] * lam ) print ( \"Matrix A : \" , ' \\n ' , Matrix ) #Subtitution x = np . zeros ( n , float ) for m in range ( n - 1 , - 1 , - 1 ): x [ m ] = ( Hasil [ m ] - np . dot ( Matrix [ m , m + 1 : n ], x [ m + 1 : n ])) / Matrix [ m , m ] print ( 'Nilai X ' , m + 1 , '=' , x [ m ]) Output: Masukkan ukuran Matrix: 3 Masukkan Nilai: 2 Masukkan Nilai: -2 Masukkan Nilai: 5 Masukkan Nilai: 1 Masukkan Nilai: 5 Masukkan Nilai: 2 Masukkan Nilai: 4 Masukkan Nilai: 5 Masukkan Nilai: 2 Masukkan Hasil: 12 Masukkan Hasil: 3 Masukkan Hasil: -4 Matrix A : [[ 2. -2. 5. ] [ 0. 6. -0.5 ] [ 0. 0. -7.25]] Nilai X 3 = 3.2413793103448274 Nilai X 2 = -0.2298850574712644 Nilai X 1 = -2.333333333333332 jadi panjang Matrix yang dibuat dalam Program Diatas adalah 3 variabel. |2 -2 5| |12| |1 5 2|=| 3 | |4 5 2| |-4| pivot yang dibentuk adalah a1.1,a2.2,dan a3.3 sehingga semua angka yang ada dibawah pivot akan dikonversikan menjadi nol sesuai hasil program dan hasil dari persamaan diatas menghasilkan x1=-2.333333333, x2=-0.22988505 dan x3=3.2413793","title":"Listing Program"},{"location":"pers_linier/#eliminasi-gauss-jacobi","text":"Metode Iterasi Jacobi merupakan salah satu bidang analisis numerik yang digunakan untuk menyelesaikan permasalahan Persamaan Linier dan sering dijumpai dalam berbagai disiplin ilmu. Metode Iterasi Jacobi merupakan salah satu metode tak langsung, yaitu bermula dari suatu hampiran penyelesaian awal dan kemudian berusaha memperbaiki hampiran dalam tak berhingga namun langkah konvergen. Metode Iterasi Jacobi ini digunakan untuk menyelesaikan persamaan Linier berukuran besar dan proporsi koefisien nolnya besar. Metode ini ditemukan oleh Matematikawan yang berasal dari Jerman,Carl,Gustav,Jacobi. Penemuan ini diperkirakan pada tahun 1800-an.","title":"Eliminasi Gauss Jacobi"},{"location":"pers_linier/#listing-program_1","text":"from pprint import pprint from numpy import array , zeros , diag , diagflat , dot import numpy as np def jacobi ( A , b , N = 25 , x = None ): #Membuat iniial guess if x is None : x = zeros ( len ( A [ 0 ])) #Membuat vektor dari elemen matrix A D = diag ( A ) R = A - diagflat ( D ) #Iterasi for i in range ( N ): x = ( b - dot ( R , x )) / D return x Mat1 = [] Mat2 = [] n = int ( input ( \"Masukkan ukuran Matrix: \" )) for i in range ( n ): baris = [] for i in range ( n ): a = int ( input ( \"Masukkan Nilai: \" )) baris . append ( a ) Mat1 . append ( baris ) for i in range ( n ): h = int ( input ( \"Masukkan Hasil: \" )) Mat2 . append ( h ) A = array ( Mat1 , float ) b = array ( Mat2 , float ) x = len ( Mat1 ) guess = np . zeros ( x , float ) sol = jacobi ( A , b , N = 25 , x = guess ) print ( \"A:\" ) pprint ( A ) print ( \"b:\" ) pprint ( b ) print ( \"x:\" ) pprint ( sol ) Output: Masukkan ukuran Matrix: 3 Masukkan Nilai: 3 Masukkan Nilai: 1 Masukkan Nilai: -1 Masukkan Nilai: 4 Masukkan Nilai: 7 Masukkan Nilai: -3 Masukkan Nilai: 2 Masukkan Nilai: -2 Masukkan Nilai: 5 Masukkan Hasil: 5 Masukkan Hasil: 20 Masukkan Hasil: 10 A: array([[ 3., 1., -1.], [ 4., 7., -3.], [ 2., -2., 5.]]) b: array([ 5., 20., 10.]) x: array([1.50602413, 3.13253016, 2.6506024 ])","title":"Listing Program"},{"location":"pers_linier/#program-gauss-seidel","text":"","title":"Program Gauss Seidel"},{"location":"pers_linier/#listing-program_2","text":"def seidel ( a , x , b ): #Mencari Panjang Matrix n = len ( a ) for j in range ( 0 , n ): d = b [ j ] #Menghitung xi, yi, zi for i in range ( 0 , n ): if ( j != i ): d -= a [ j ][ i ] * x [ i ] x [ j ] = d / a [ j ][ j ] #Solusi return x m = int ( input ( \"Masukkan Panjang Matrix: \" )) a = [] b = [] for k in range ( m ): mat1 = [] for i in range ( m ): l = float ( input ( \"Masukkan a\" + str ( k + 1 ) + \",\" + str ( i + 1 ) + \": \" )) mat1 . append ( l ) h = float ( input ( \"Masukkan Hasil: \" )) b . append ( h ) a . append ( mat1 ) n = 3 x = [ 0 , 0 , 0 ] print ( x ) for i in range ( 0 , 100 ): x = seidel ( a , x , b ) print ( x ) Output: Masukkan Panjang Matrix: 3 Masukkan a1,1: 4 Masukkan a1,2: -1 Masukkan a1,3: 1 Masukkan Hasil: 7 Masukkan a2,1: 4 Masukkan a2,2: -8 Masukkan a2,3: 1 Masukkan Hasil: -21 Masukkan a3,1: -2 Masukkan a3,2: 1 Masukkan a3,3: 5 Masukkan Hasil: 15 [0, 0, 0] [1.75, 3.5, 3.0] [1.875, 3.9375, 2.9625] [1.99375, 3.9921875, 2.9990625] [1.99828125, 3.9990234375, 2.9995078125] [1.99987890625, 3.9998779296875, 2.9999759765625003] [1.99997548828125, 3.9999847412109375, 2.999993247070312] [1.9999978735351562, 3.9999980926513667, 2.999999530883789] [1.9999996404418945, 3.9999997615814205, 2.9999999038604734] [1.9999999644302369, 3.9999999701976776, 2.9999999917325595] [1.9999999946162794, 3.9999999962747097, 2.99999999859157] [1.9999999994207849, 3.9999999995343387, 2.9999999998614464] [1.9999999999182232, 3.999999999941793, 2.999999999978931] [1.9999999999907154, 3.999999999992724, 2.9999999999977414] [1.9999999999987457, 3.9999999999990905, 2.9999999999996803] [1.9999999999998526, 3.9999999999998863, 2.9999999999999636] [1.9999999999999807, 3.999999999999986, 2.999999999999995] [1.9999999999999978, 3.9999999999999987, 2.9999999999999996] [1.9999999999999996, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] Dari soal diatas persamaan yang dipilih adalah 4x-y+z=7, 4x-8y+z=-21 dan -2x+y+5z=15. Iterasi yang digunakan sebanyak 100 iterasi sehingga dapat menghasilkan x=2,y=4 dan z=3.","title":"Listing Program"},{"location":"start/","text":"Identitas \u00b6 Yogi Widyanto 180411100049 Komputasi Numerik 4B MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"Identitas"},{"location":"start/#identitas","text":"Yogi Widyanto 180411100049 Komputasi Numerik 4B MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"Identitas"},{"location":"tugas_2/","text":"Numerical Solution of Algebraic and Transcendental Equation \u00b6 Metode Bisection \u00b6 Metode Bisection ini membagi range menjadi 2 bagian, dari dua bagian ini dipilih bagian mana yang mengandung akar sedangkan bagian yang tidak mengandung akar akan dibuang. Hal ini dilakukan berulang-ulang hingga diperoleh suatu akar persamaan. Algoritma metode bisection Definisikan fungsi f(x) yang akan dicari akarnya tentukan range atau nilai a dan b tentukan nilai toleransi dan iterasi maksimum hitung f(a) dan f(b) jika f(a)*f(b)>0 maka proses dihentikan karena tidak ada akar jika f(a)*f(b)<0 maka................. hitung nilai c $$ c =\\frac{(a+b)}{2} $$ hitung nilai f(c) Bila f(c).f(a)<0 maka b = c dan f(b)=f(c), bila tidak maka a=c dan f(a)=f(c) Jika |b-a|< e atau iterasi > iterasi maks maka proses dihentikan dan didapatkan akar x, bila tidak, ulangi langkah 6 Metode Regula Falsi \u00b6 Metode regula falsi adalah Metode pencarian akar persamaan dengan memanfaatkan kemiringan dan selisih tinggi dari dua titik batas range. Dua titik a dan b pada fungsi f(x) digunakan untuk mengestimasi posisi c dari akar interpolasi linier. Dikenal dengan metode False Position Metode ini juga merupakan penyempurna dari metode bisection Rumus c dari regula falsi : $$ c = a-f(a) \\frac{(b-a)}{f(b)-f(a)} $$ Algoritma metode regula falsi (benerin lagii) Definisikan fungsi f(x) yang akan dicari akarnya tentukan batas atas dan batas bawah tentukan nilai toleransi dan iterasi maksimum hitung f(a) dan f(b) jika f(a)*f(b)>0 maka proses dihentikan karena tidak ada akar jika f(a)*f(b)<0 maka................. hitung nilai c $$ c =\\frac{(a+b)}{2} $$ hitung nilai f(c) Bila f(c).f(a)<0 maka b = c dan f(b)=f(c), bila tidak maka a=c dan f(a)=f(c) Jika |b-a|< e atau iterasi > iterasi maks maka proses dihentikan dan didapatkan akar x, bila tidak, ulangi langkah 6 Metode Newton Raphson \u00b6 \u200b Dalam analisis numerik, metode Newton / Newton-Raphson yang mendapat nama dari Isaac Newton dan Joseph Rapshon, merupakan metode yang paling dikenal untuk mencari akar suatu fungsi f(x) dengan pendekatan satu titik dimana fungsi f(x) mempunyai turunan. Prosedur Metode Newton : menentukan x_0 sebagai titik awal, kemudian menarik garis lurus yang menyinggung titik f(x_0) . Hal ini berakibat garis I memotong sumbu x di titik x_1 Setelah itu diulangi langkah sebelumnya tapi sekarang x_1 dianggap sebagai titik awalnya. Dari mengulang langkah-langkah sebelumnya akan mendapatkan x_2 , x_3 , ... , x_n dengan x_n yang diperoleh adalah bilangan riil yang merupakan akar atau mendekati akar yang sebenarnya. persamaan garis I : y - y_0 = m(x - x_0) $$ y - f(x_0) = f'(x_0)(x - x_0) $$ x_1 perpotongan garis I dengan sumbu - x $$ 0 - f(x_0) = f'(x_0)(x - x_0) $$ y = 0 dan x = x_1 maka koordinat titik ( x_1 ,0) $$ - \\frac{f(x_0)}{f'(x_0)} = (x_1 - x_0) $$ sehingga di dapat sebuah rumus : $$ f'(x_n)=\\frac{f(x_n)-0}{f'(x_n)-{x_{n+1}}} $$ atau dapat diatur kembali menjadi : $$ x_1 = x_0 - \\frac{f(x_0)}{f'(x_0)} , x_2 = x_1 - \\frac{f(x_1)}{f'(x_1)}, ... , x_{n+1} = x_{n} - \\frac{f(x_{n})}{f'(x_{n})} $$ Metode Secant \u00b6 Metode Newton Raphson memerlukan perhitungan turunan fungsi f\u2019(x). Tidak semua fungsi mudah dicari turunannya terutama fungsi yang bentuknya rumit. Turunan fungsi dapat dihilangkan dengan cara menggantinya dengan bentuk lain yang ekivalen.Modifikasi metode Newton Raphson dinamakan metode Secant. Rumus Metode Secant $$ x_{r+1}=x_r-\\frac{f(x_r)(x_r - x_{r-1})}{f(x_r)-{x_{r+1}}} $$ Algoritma Metode Secant Definisikan f(x) Definisikan toleransi error e dan iterasi maksimum (n) Masukan dua nilai pendekatan awal yang diantaranya terdapat akar yaitu x0 dan x1 ,sebaiknya gunakan metode tabel untuk menjamin titik pendekatanya adalah titik pendekatan yang konvergensinya pada akar persamaan yang diharapkan. Hitung f(x0 ) dan f(x1) Untuk iterasi 1 s/d N : $$ x_{r+1}=x_r-\\frac{f(x_r)(x_r - x_{r-1})}{f(x_r)-{x_{r+1}}} $$ $$ Hitungf(x_{r+1}) $$ Implementasi \u00b6 Metode Bisection \u00b6 def bis ( a , b , n ): e = 0.001 fa = a ** 2 - 5 * a + 6 fb = b ** 2 - 5 * b + 6 if fa * fb < 0 : x = ( a + b ) / 2 fx = x ** 2 - 5 * x + 6 if fa * fx < 0 : b = x elif fx * fb < 0 : a = x if abs ( a - b ) < e : print ( \"Jumlah Iterasi : \" , n ) print ( x ) else : n += 1 print ( \"iterasi ke-\" + str ( n )) bis ( a , b , n ) else : if fa < fb : a -= 0.1 elif fb < fa : b += 0.1 bis ( a , b , n ) a = float ( input ( \"Masukkan nilai a : \" )) b = float ( input ( \"Masukkan nilai b : \" )) bis ( a , b , 0 ) Metode Regula Falsi \u00b6 def Regfal ( a , b , n ): e = 0.001 fa = a ** 2 - 5 * a + 6 fb = b ** 2 - 5 * b + 6 if fa * fb < 0 : n += 1 print ( \"iterasi ke-\" + str ( n )) x = (( a * abs ( fb )) + ( b * abs ( fa ))) / ( abs ( fa ) + abs ( fb )) fx = x ** 2 - 5 * x + 6 if fa * fx < 0 : b = x else : a = x if abs ( a - b ) < e : print ( x ) else : Regfal ( a , b , n ) else : if fa < fb : a -= 0.1 else : b += 0.1 Regfal ( a , b , n ) a = float ( input ( \"Masukkan interval a : \" )) b = float ( input ( \"Masukkan interval b : \" )) Regfal ( a , b , 0 ) Metode Newton Rapshon \u00b6 #Newton-Raphson x = float ( input ( \"Masukkan nilai awal x : \" )) n = 0 e = 0.001 while n >= 0 : print ( \"iterasi saat X\" + str ( n )) fx = x ** 2 - 5 * x + 6 fax = 2 * x - 5 x1 = x - ( fx / fax ) if abs ( x1 - x ) < e or n >= 100 : print ( \"Jumlah iterasi : \" , n + 1 ) print ( x ) break else : x = x1 n += 1 Metode Secant \u00b6 #Secant def Secant ( a , b , n ): e = 0.001 fa = a ** 2 - 5 * a + 6 fb = b ** 2 - 5 * b + 6 x = a - (( b - a ) / ( fb - fa )) * fa fx = x ** 2 - 5 * x + 6 n += 1 print ( \"iterasi ke-\" + str ( n )) if abs ( a - b ) < e : print ( \"Jumlah iterasi :\" , n ) print ( x ) else : a = b b = x Secant ( a , b , n ) a = float ( input ( \"Masukkan nilai a : \" )) b = float ( input ( \"Masukkan nilai b : \" )) n = 0 Secant ( a , b , 0 ) MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"Mencari Akar Persamaan"},{"location":"tugas_2/#numerical-solution-of-algebraic-and-transcendental-equation","text":"","title":"Numerical Solution of Algebraic and Transcendental Equation"},{"location":"tugas_2/#metode-bisection","text":"Metode Bisection ini membagi range menjadi 2 bagian, dari dua bagian ini dipilih bagian mana yang mengandung akar sedangkan bagian yang tidak mengandung akar akan dibuang. Hal ini dilakukan berulang-ulang hingga diperoleh suatu akar persamaan. Algoritma metode bisection Definisikan fungsi f(x) yang akan dicari akarnya tentukan range atau nilai a dan b tentukan nilai toleransi dan iterasi maksimum hitung f(a) dan f(b) jika f(a)*f(b)>0 maka proses dihentikan karena tidak ada akar jika f(a)*f(b)<0 maka................. hitung nilai c $$ c =\\frac{(a+b)}{2} $$ hitung nilai f(c) Bila f(c).f(a)<0 maka b = c dan f(b)=f(c), bila tidak maka a=c dan f(a)=f(c) Jika |b-a|< e atau iterasi > iterasi maks maka proses dihentikan dan didapatkan akar x, bila tidak, ulangi langkah 6","title":"Metode Bisection"},{"location":"tugas_2/#metode-regula-falsi","text":"Metode regula falsi adalah Metode pencarian akar persamaan dengan memanfaatkan kemiringan dan selisih tinggi dari dua titik batas range. Dua titik a dan b pada fungsi f(x) digunakan untuk mengestimasi posisi c dari akar interpolasi linier. Dikenal dengan metode False Position Metode ini juga merupakan penyempurna dari metode bisection Rumus c dari regula falsi : $$ c = a-f(a) \\frac{(b-a)}{f(b)-f(a)} $$ Algoritma metode regula falsi (benerin lagii) Definisikan fungsi f(x) yang akan dicari akarnya tentukan batas atas dan batas bawah tentukan nilai toleransi dan iterasi maksimum hitung f(a) dan f(b) jika f(a)*f(b)>0 maka proses dihentikan karena tidak ada akar jika f(a)*f(b)<0 maka................. hitung nilai c $$ c =\\frac{(a+b)}{2} $$ hitung nilai f(c) Bila f(c).f(a)<0 maka b = c dan f(b)=f(c), bila tidak maka a=c dan f(a)=f(c) Jika |b-a|< e atau iterasi > iterasi maks maka proses dihentikan dan didapatkan akar x, bila tidak, ulangi langkah 6","title":"Metode Regula Falsi"},{"location":"tugas_2/#metode-newton-raphson","text":"\u200b Dalam analisis numerik, metode Newton / Newton-Raphson yang mendapat nama dari Isaac Newton dan Joseph Rapshon, merupakan metode yang paling dikenal untuk mencari akar suatu fungsi f(x) dengan pendekatan satu titik dimana fungsi f(x) mempunyai turunan. Prosedur Metode Newton : menentukan x_0 sebagai titik awal, kemudian menarik garis lurus yang menyinggung titik f(x_0) . Hal ini berakibat garis I memotong sumbu x di titik x_1 Setelah itu diulangi langkah sebelumnya tapi sekarang x_1 dianggap sebagai titik awalnya. Dari mengulang langkah-langkah sebelumnya akan mendapatkan x_2 , x_3 , ... , x_n dengan x_n yang diperoleh adalah bilangan riil yang merupakan akar atau mendekati akar yang sebenarnya. persamaan garis I : y - y_0 = m(x - x_0) $$ y - f(x_0) = f'(x_0)(x - x_0) $$ x_1 perpotongan garis I dengan sumbu - x $$ 0 - f(x_0) = f'(x_0)(x - x_0) $$ y = 0 dan x = x_1 maka koordinat titik ( x_1 ,0) $$ - \\frac{f(x_0)}{f'(x_0)} = (x_1 - x_0) $$ sehingga di dapat sebuah rumus : $$ f'(x_n)=\\frac{f(x_n)-0}{f'(x_n)-{x_{n+1}}} $$ atau dapat diatur kembali menjadi : $$ x_1 = x_0 - \\frac{f(x_0)}{f'(x_0)} , x_2 = x_1 - \\frac{f(x_1)}{f'(x_1)}, ... , x_{n+1} = x_{n} - \\frac{f(x_{n})}{f'(x_{n})} $$","title":"Metode Newton Raphson"},{"location":"tugas_2/#metode-secant","text":"Metode Newton Raphson memerlukan perhitungan turunan fungsi f\u2019(x). Tidak semua fungsi mudah dicari turunannya terutama fungsi yang bentuknya rumit. Turunan fungsi dapat dihilangkan dengan cara menggantinya dengan bentuk lain yang ekivalen.Modifikasi metode Newton Raphson dinamakan metode Secant. Rumus Metode Secant $$ x_{r+1}=x_r-\\frac{f(x_r)(x_r - x_{r-1})}{f(x_r)-{x_{r+1}}} $$ Algoritma Metode Secant Definisikan f(x) Definisikan toleransi error e dan iterasi maksimum (n) Masukan dua nilai pendekatan awal yang diantaranya terdapat akar yaitu x0 dan x1 ,sebaiknya gunakan metode tabel untuk menjamin titik pendekatanya adalah titik pendekatan yang konvergensinya pada akar persamaan yang diharapkan. Hitung f(x0 ) dan f(x1) Untuk iterasi 1 s/d N : $$ x_{r+1}=x_r-\\frac{f(x_r)(x_r - x_{r-1})}{f(x_r)-{x_{r+1}}} $$ $$ Hitungf(x_{r+1}) $$","title":"Metode Secant"},{"location":"tugas_2/#implementasi","text":"","title":"Implementasi"},{"location":"tugas_2/#metode-bisection_1","text":"def bis ( a , b , n ): e = 0.001 fa = a ** 2 - 5 * a + 6 fb = b ** 2 - 5 * b + 6 if fa * fb < 0 : x = ( a + b ) / 2 fx = x ** 2 - 5 * x + 6 if fa * fx < 0 : b = x elif fx * fb < 0 : a = x if abs ( a - b ) < e : print ( \"Jumlah Iterasi : \" , n ) print ( x ) else : n += 1 print ( \"iterasi ke-\" + str ( n )) bis ( a , b , n ) else : if fa < fb : a -= 0.1 elif fb < fa : b += 0.1 bis ( a , b , n ) a = float ( input ( \"Masukkan nilai a : \" )) b = float ( input ( \"Masukkan nilai b : \" )) bis ( a , b , 0 )","title":"Metode Bisection"},{"location":"tugas_2/#metode-regula-falsi_1","text":"def Regfal ( a , b , n ): e = 0.001 fa = a ** 2 - 5 * a + 6 fb = b ** 2 - 5 * b + 6 if fa * fb < 0 : n += 1 print ( \"iterasi ke-\" + str ( n )) x = (( a * abs ( fb )) + ( b * abs ( fa ))) / ( abs ( fa ) + abs ( fb )) fx = x ** 2 - 5 * x + 6 if fa * fx < 0 : b = x else : a = x if abs ( a - b ) < e : print ( x ) else : Regfal ( a , b , n ) else : if fa < fb : a -= 0.1 else : b += 0.1 Regfal ( a , b , n ) a = float ( input ( \"Masukkan interval a : \" )) b = float ( input ( \"Masukkan interval b : \" )) Regfal ( a , b , 0 )","title":"Metode Regula Falsi"},{"location":"tugas_2/#metode-newton-rapshon","text":"#Newton-Raphson x = float ( input ( \"Masukkan nilai awal x : \" )) n = 0 e = 0.001 while n >= 0 : print ( \"iterasi saat X\" + str ( n )) fx = x ** 2 - 5 * x + 6 fax = 2 * x - 5 x1 = x - ( fx / fax ) if abs ( x1 - x ) < e or n >= 100 : print ( \"Jumlah iterasi : \" , n + 1 ) print ( x ) break else : x = x1 n += 1","title":"Metode Newton Rapshon"},{"location":"tugas_2/#metode-secant_1","text":"#Secant def Secant ( a , b , n ): e = 0.001 fa = a ** 2 - 5 * a + 6 fb = b ** 2 - 5 * b + 6 x = a - (( b - a ) / ( fb - fa )) * fa fx = x ** 2 - 5 * x + 6 n += 1 print ( \"iterasi ke-\" + str ( n )) if abs ( a - b ) < e : print ( \"Jumlah iterasi :\" , n ) print ( x ) else : a = b b = x Secant ( a , b , n ) a = float ( input ( \"Masukkan nilai a : \" )) b = float ( input ( \"Masukkan nilai b : \" )) n = 0 Secant ( a , b , 0 ) MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"Metode Secant"}]}
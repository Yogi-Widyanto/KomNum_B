{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Error in Numerical Computations \u00b6 Nama : Yogi Widyanto NIM : 180411100049 Materi \u00b6 Error atau Galat \u00b6 Error / Galat merupakan perbedaan antara hasil penyelesaian suatu model matematik secara numeric dengan penyelesaian secara analitis. Kesalahan yang terjadi sangatlah penting, karena kesalahan dalam pemakaian algoritma pendekatan akan menyebabkan nilai kesalahan yang besar. Sehingga pendekatan metode numerik selalu membahas tingkat kesalahan dan tingkat kecepatan proses yang akan terjadi. Round of Error \u00b6 Perhitungan dengan metode numerik hampir selalu menggunakan bilangan riil. Masalah timbul bila komputasi numerik dikerjakan oleh mesin (dalam hal ini komputer) karena semua bilangan riil tidak dapat disajikan secara tepat di dalam komputer. Sebagai contoh 1/6 = 0.166666666\u2026 Truncation Error \u00b6 Kesalahan pemotongan terjadi ketika suatu rumus komputasi disederhanakan dengan cara membuang suku yang berderajat tinggi.Metode numerik menggunakan pendekatan untuk menyelesaikan masalah. Kesalahan yang diperkenalkan oleh aproksimasi adalah kesalahan pemotongan. Rumus Truncation errors : Deret Maclaurin \u00b6 Deret Maclaurin sangat berguna dalam komputasi numerik dalam menghitung nilai - nilai fungsi yang susah dihitung secara manual. Contoh sin(x), cos(x), e^x berikut algoritma mclaurin Deret MacLaurin biasa disebut sebagai deret Taylor baku, kerena deret maclaurin merupakan standar atau dasar yang berlaku dengan a=0. Atau persamaan Deret MacLaurin diatas dapat ditulis seperti berikut $$ f(x) = \\sum \\limits_{i=0}^{n} {f^i(0)x^i \\over i!} $$ Hasil Code \u00b6 Berikut implementasi deret maclaurin \u00b6 import math print ( \"Soal : e^(3x)\" ) print ( \" \" ) x = 1 var = 1 fa = 1 kondisi = True while kondisi == True : f = (( 3 ** var ) * ( x ** var )) / math . factorial ( var ) fnew = fa + f test = fnew - fa print ( \"s\" , var , \"=\" , fa ) print ( \"s\" , var + 1 , \"=\" , fnew ) print ( \"selisih : \" , test ) print ( \"--------------------------------------------------\" ) if test <= 0.0001 : break else : fa += f var += 1 print ( \"\" ) print ( 'total iterasi : ' , var ) print ( 'untuk x =' , x ) hasil dari program diatas Soal : e^(3x) s 1 = 1 s 2 = 4.0 selisih : 3.0 -------------------------------------------------- s 2 = 4.0 s 3 = 8.5 selisih : 4.5 -------------------------------------------------- s 3 = 8.5 s 4 = 13.0 selisih : 4.5 -------------------------------------------------- s 4 = 13.0 s 5 = 16.375 selisih : 3.375 -------------------------------------------------- s 5 = 16.375 s 6 = 18.4 selisih : 2.0249999999999986 -------------------------------------------------- s 6 = 18.4 s 7 = 19.412499999999998 selisih : 1.0124999999999993 -------------------------------------------------- s 7 = 19.412499999999998 s 8 = 19.846428571428568 selisih : 0.4339285714285701 -------------------------------------------------- s 8 = 19.846428571428568 s 9 = 20.009151785714284 selisih : 0.162723214285716 -------------------------------------------------- s 9 = 20.009151785714284 s 10 = 20.063392857142855 selisih : 0.05424107142857082 -------------------------------------------------- s 10 = 20.063392857142855 s 11 = 20.079665178571425 selisih : 0.016272321428569825 -------------------------------------------------- s 11 = 20.079665178571425 s 12 = 20.08410308441558 selisih : 0.004437905844156376 -------------------------------------------------- s 12 = 20.08410308441558 s 13 = 20.08521256087662 selisih : 0.001109476461039094 -------------------------------------------------- s 13 = 20.08521256087662 s 14 = 20.08546859390609 selisih : 0.0002560330294691937 -------------------------------------------------- s 14 = 20.08546859390609 s 15 = 20.08552345812669 selisih : 5.4864220601302804e-05 -------------------------------------------------- total iterasi : 14 untuk x = 1 Penjelasan \u00b6 import math # import module math print ( \"Soal : e^(3x)\" ) print ( \" \" ) x = 1 # nilai x var = 1 # untuk jumlah iterasi dan juga pangkat fa = 1 # nilai f awal kondisi = True # kondisi awal untuk looping while kondisi == True : f = (( 3 ** var ) * ( x ** var )) / math . factorial ( var ) # f=3^var*(x^var)/(var!) atau turunanya fnew = fa + f # fnew untuk menjumlahkan fa dengan f selanjutnya test = fnew - fa # mengetahui selisih print ( \"s\" , var , \"=\" , fa ) print ( \"s\" , var + 1 , \"=\" , fnew ) print ( \"selisih : \" , test ) print ( \"--------------------------------------------------\" ) if test <= 0.0001 : # jika selisih <= 0.0001 maka break break else : fa += f # jika tidak fawal diganti f var += 1 # var ditambah 1 print ( \"\" ) print ( 'total iterasi : ' , var ) print ( 'untuk x =' , x ) MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"Error in Numerical"},{"location":"#error-in-numerical-computations","text":"Nama : Yogi Widyanto NIM : 180411100049","title":"Error in Numerical Computations"},{"location":"#materi","text":"","title":"Materi"},{"location":"#error-atau-galat","text":"Error / Galat merupakan perbedaan antara hasil penyelesaian suatu model matematik secara numeric dengan penyelesaian secara analitis. Kesalahan yang terjadi sangatlah penting, karena kesalahan dalam pemakaian algoritma pendekatan akan menyebabkan nilai kesalahan yang besar. Sehingga pendekatan metode numerik selalu membahas tingkat kesalahan dan tingkat kecepatan proses yang akan terjadi.","title":"Error atau Galat"},{"location":"#round-of-error","text":"Perhitungan dengan metode numerik hampir selalu menggunakan bilangan riil. Masalah timbul bila komputasi numerik dikerjakan oleh mesin (dalam hal ini komputer) karena semua bilangan riil tidak dapat disajikan secara tepat di dalam komputer. Sebagai contoh 1/6 = 0.166666666\u2026","title":"Round of Error"},{"location":"#truncation-error","text":"Kesalahan pemotongan terjadi ketika suatu rumus komputasi disederhanakan dengan cara membuang suku yang berderajat tinggi.Metode numerik menggunakan pendekatan untuk menyelesaikan masalah. Kesalahan yang diperkenalkan oleh aproksimasi adalah kesalahan pemotongan. Rumus Truncation errors :","title":"Truncation Error"},{"location":"#deret-maclaurin","text":"Deret Maclaurin sangat berguna dalam komputasi numerik dalam menghitung nilai - nilai fungsi yang susah dihitung secara manual. Contoh sin(x), cos(x), e^x berikut algoritma mclaurin Deret MacLaurin biasa disebut sebagai deret Taylor baku, kerena deret maclaurin merupakan standar atau dasar yang berlaku dengan a=0. Atau persamaan Deret MacLaurin diatas dapat ditulis seperti berikut $$ f(x) = \\sum \\limits_{i=0}^{n} {f^i(0)x^i \\over i!} $$","title":"Deret Maclaurin"},{"location":"#hasil-code","text":"","title":"Hasil Code"},{"location":"#berikut-implementasi-deret-maclaurin","text":"import math print ( \"Soal : e^(3x)\" ) print ( \" \" ) x = 1 var = 1 fa = 1 kondisi = True while kondisi == True : f = (( 3 ** var ) * ( x ** var )) / math . factorial ( var ) fnew = fa + f test = fnew - fa print ( \"s\" , var , \"=\" , fa ) print ( \"s\" , var + 1 , \"=\" , fnew ) print ( \"selisih : \" , test ) print ( \"--------------------------------------------------\" ) if test <= 0.0001 : break else : fa += f var += 1 print ( \"\" ) print ( 'total iterasi : ' , var ) print ( 'untuk x =' , x ) hasil dari program diatas Soal : e^(3x) s 1 = 1 s 2 = 4.0 selisih : 3.0 -------------------------------------------------- s 2 = 4.0 s 3 = 8.5 selisih : 4.5 -------------------------------------------------- s 3 = 8.5 s 4 = 13.0 selisih : 4.5 -------------------------------------------------- s 4 = 13.0 s 5 = 16.375 selisih : 3.375 -------------------------------------------------- s 5 = 16.375 s 6 = 18.4 selisih : 2.0249999999999986 -------------------------------------------------- s 6 = 18.4 s 7 = 19.412499999999998 selisih : 1.0124999999999993 -------------------------------------------------- s 7 = 19.412499999999998 s 8 = 19.846428571428568 selisih : 0.4339285714285701 -------------------------------------------------- s 8 = 19.846428571428568 s 9 = 20.009151785714284 selisih : 0.162723214285716 -------------------------------------------------- s 9 = 20.009151785714284 s 10 = 20.063392857142855 selisih : 0.05424107142857082 -------------------------------------------------- s 10 = 20.063392857142855 s 11 = 20.079665178571425 selisih : 0.016272321428569825 -------------------------------------------------- s 11 = 20.079665178571425 s 12 = 20.08410308441558 selisih : 0.004437905844156376 -------------------------------------------------- s 12 = 20.08410308441558 s 13 = 20.08521256087662 selisih : 0.001109476461039094 -------------------------------------------------- s 13 = 20.08521256087662 s 14 = 20.08546859390609 selisih : 0.0002560330294691937 -------------------------------------------------- s 14 = 20.08546859390609 s 15 = 20.08552345812669 selisih : 5.4864220601302804e-05 -------------------------------------------------- total iterasi : 14 untuk x = 1","title":"Berikut implementasi deret maclaurin"},{"location":"#penjelasan","text":"import math # import module math print ( \"Soal : e^(3x)\" ) print ( \" \" ) x = 1 # nilai x var = 1 # untuk jumlah iterasi dan juga pangkat fa = 1 # nilai f awal kondisi = True # kondisi awal untuk looping while kondisi == True : f = (( 3 ** var ) * ( x ** var )) / math . factorial ( var ) # f=3^var*(x^var)/(var!) atau turunanya fnew = fa + f # fnew untuk menjumlahkan fa dengan f selanjutnya test = fnew - fa # mengetahui selisih print ( \"s\" , var , \"=\" , fa ) print ( \"s\" , var + 1 , \"=\" , fnew ) print ( \"selisih : \" , test ) print ( \"--------------------------------------------------\" ) if test <= 0.0001 : # jika selisih <= 0.0001 maka break break else : fa += f # jika tidak fawal diganti f var += 1 # var ditambah 1 print ( \"\" ) print ( 'total iterasi : ' , var ) print ( 'untuk x =' , x ) MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"Penjelasan"},{"location":"Metode%20Euler/","text":"Metode Euler \u00b6 metode Euler (juga disebut metode forward Euler ) adalah prosedur numerik orde pertama untuk menyelesaikan persamaan diferensial biasa (ODE) dengan nilai awal yang diberikan. Ini adalah metode eksplisit paling dasar untuk integrasi numerik persamaan diferensial biasa dan merupakan metode Runge-Kutta paling sederhana. Metode Euler adalah metode urutan pertama, yang berarti bahwa kesalahan lokal (kesalahan per langkah) sebanding dengan kuadrat ukuran langkah, dan kesalahan global (kesalahan pada waktu tertentu) sebanding dengan ukuran langkah. Metode Euler sering berfungsi sebagai dasar untuk membangun metode yang lebih kompleks, misalnya, metode prediktor-korektor. $$ \\frac{dx}{dy} = f(x,y) $$ dengan nilai awal yaitu $$ y_{0}=y(x_{0}) $$ dengan langkah yang didefinisikan sebagai berikut $$ h=x_{n+1}-x_n $$ Kesimpulan dari persamaan euler adalah sebagai berikut : $$ y_{j+1}=y_j+hf(x_j,y_j) $$ Soal dan Source Code dari Metode Euler \u00b6 soal : Buatlah program untuk menyelesaikan persamaan differensial biasa berikut dengan menggunakan metode Euler $$ \\frac{dx}{dy} = 1+x^2 $$ dengan : $$ y_1=-4 $$ Untuk menentukan y(1.01), y(1.02) dan y(1.03). Jawab : def metodeEuler ( x , n ): y0 =- 4 h = 0.01 for i in range ( 0 , n ): euler = y0 print ( 'x' + str ( i ) + ' = ' + str ( x )) print ( 'y' + str ( i ) + ' = ' + str ( euler )) print ( '======================================' ) euler = y0 + ( h * ( 1 + x ** 2 )) x += h y0 = euler a = int ( input ( \"Inputan x yaitu : \" )) b = int ( input ( \"Iterasi sebanyak : \" )) metodeEuler ( a , b ) dengan hasil running sebagai berikut : Inputan x yaitu : 1 Iterasi sebanyak : 4 x0 = 1 y0 = - 4 ====================================== x1 = 1.01 y1 = - 3.98 ====================================== x2 = 1.02 y2 = - 3.959799 ====================================== x3 = 1.03 y3 = - 3.9393949999999998 ====================================== Terimakasih MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"Metode Euler"},{"location":"Metode%20Euler/#metode-euler","text":"metode Euler (juga disebut metode forward Euler ) adalah prosedur numerik orde pertama untuk menyelesaikan persamaan diferensial biasa (ODE) dengan nilai awal yang diberikan. Ini adalah metode eksplisit paling dasar untuk integrasi numerik persamaan diferensial biasa dan merupakan metode Runge-Kutta paling sederhana. Metode Euler adalah metode urutan pertama, yang berarti bahwa kesalahan lokal (kesalahan per langkah) sebanding dengan kuadrat ukuran langkah, dan kesalahan global (kesalahan pada waktu tertentu) sebanding dengan ukuran langkah. Metode Euler sering berfungsi sebagai dasar untuk membangun metode yang lebih kompleks, misalnya, metode prediktor-korektor. $$ \\frac{dx}{dy} = f(x,y) $$ dengan nilai awal yaitu $$ y_{0}=y(x_{0}) $$ dengan langkah yang didefinisikan sebagai berikut $$ h=x_{n+1}-x_n $$ Kesimpulan dari persamaan euler adalah sebagai berikut : $$ y_{j+1}=y_j+hf(x_j,y_j) $$","title":"Metode Euler"},{"location":"Metode%20Euler/#soal-dan-source-code-dari-metode-euler","text":"soal : Buatlah program untuk menyelesaikan persamaan differensial biasa berikut dengan menggunakan metode Euler $$ \\frac{dx}{dy} = 1+x^2 $$ dengan : $$ y_1=-4 $$ Untuk menentukan y(1.01), y(1.02) dan y(1.03). Jawab : def metodeEuler ( x , n ): y0 =- 4 h = 0.01 for i in range ( 0 , n ): euler = y0 print ( 'x' + str ( i ) + ' = ' + str ( x )) print ( 'y' + str ( i ) + ' = ' + str ( euler )) print ( '======================================' ) euler = y0 + ( h * ( 1 + x ** 2 )) x += h y0 = euler a = int ( input ( \"Inputan x yaitu : \" )) b = int ( input ( \"Iterasi sebanyak : \" )) metodeEuler ( a , b ) dengan hasil running sebagai berikut : Inputan x yaitu : 1 Iterasi sebanyak : 4 x0 = 1 y0 = - 4 ====================================== x1 = 1.01 y1 = - 3.98 ====================================== x2 = 1.02 y2 = - 3.959799 ====================================== x3 = 1.03 y3 = - 3.9393949999999998 ====================================== Terimakasih MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"Soal dan Source Code dari Metode Euler"},{"location":"Metode%20Monte%20Carlo/","text":"Metode Monte Carlo \u00b6 Pengertian \u00b6 Metode Monte Carlo adalah algoritme komputasi untuk mensimulasikan berbagai perilaku sistem fisika dan matematika. Penggunaan klasik metode ini adalah untuk mengevaluasi integral definit , terutama integral multidimensi dengan syarat dan batasan yang rumit. Metode Monte Carlo sangat penting dalam fisika komputasi dan bidang terapan lainnya, dan memiliki aplikasi yang beragam mulai dari perhitungan kromodinamika kuantum esoterik hingga perancangan aerodinamika. Metode ini terbukti efisien dalam memecahkan persamaan diferensial integral medan radians, sehingga metode ini digunakan dalam perhitungan iluminasi global yang menghasilkan gambar-gambar fotorealistik model tiga dimensi, dimana diterapkan dalam video games , arsitektur , perancangan , film yang dihasilkan oleh komputer, efek-efek khusus dalam film, bisnis, ekonomi, dan bidang lainnya. (source:wikipedia) Karena algoritme ini memerlukan pengulangan (repetisi) dan perhitungan yang amat kompleks, metode Monte Carlo pada umumnya dilakukan menggunakan komputer, dan memakai berbagai teknik simulasi komputer. Algoritme Monte Carlo adalah metode Monte Carlo numerik yang digunakan untuk menemukan solusi problem matematis (yang dapat terdiri dari banyak variabel) yang susah dipecahkan, misalnya dengan kalkulus integral, atau metode numerik lainnya. Jawaban soal nomor 3 \u00b6 from scipy import random import numpy as np import matplotlib.pyplot as plt a = 0 b = 2 N = 2500 #function for integral def func ( x ): return ( 4 - x ** 2 ) ** 0.5 area = [] for i in range ( N ): xrand = np . zeros ( N ) for i in range ( len ( xrand )): xrand [ i ] = random . uniform ( a , b ) integral = 0.0 for i in range ( N ): integral += func ( xrand [ i ]) jawab = ( b - a ) / float ( N ) * integral area . append ( jawab ) plt . title ( \"Nilai phi\" ) plt . hist ( area , bins = 30 , ec = 'black' ) plt . xlabel ( \"Area\" ) plt . show () hasil running percobaan 1 Pada percobaan pertama Nilai Phi menunjukkan X=3.14465 y=255.824 hasil running percobaan 2 Pada percobaan kedua Nilai Phi menunjukkan x=3.14118 y=286.582 Jawaban soal nomor 3 \u00b6 from scipy import random #memanggil library random dari scipy import numpy as np #memanggil library numpy a = - 1 b = 1 N = 100 n = 3 xrand = np . zeros ( N ) #dx yrand = np . zeros ( N ) #dy zrand = np . zeros ( N ) #dz #fungsi np.zeros mengembalikan array baru dengan bentuk dari tipe yang diberikan, di mana nilai elemen sebagai 0. integral = 0.0 for i in range ( n + 1 ): for i in range ( len ( xrand )): xrand [ i ] = random . uniform ( a , b ) for i in range ( len ( yrand )): yrand [ i ] = random . uniform ( a , b ) for i in range ( len ( zrand )): zrand [ i ] = random . uniform ( a , b ) def func ( x , y , z ): return ( x ** 2 ) + ( y ** 2 ) + ( z ** 2 ) for i in range ( N ): integral += func ( xrand [ i ], yrand [ i ], zrand [ i ]) jwb = ( b - a ) / float ( N ) * integral print ( \"Hasil : \" , jwb ) #Percobaan 1 RESTART: C:\\Users\\hp\\AppData\\Local\\Programs\\Python\\Python37-32\\nomor3.py Hasil : 7.985285659898637 Process finished with exit code 0 #Percobaan 2 RESTART: C:\\Users\\hp\\AppData\\Local\\Programs\\Python\\Python37-32\\nomor3.py Hasil : 8.02539169028922 Process finished with exit code 0 Terima kasih . . . MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"Metode Monte Carlo"},{"location":"Metode%20Monte%20Carlo/#metode-monte-carlo","text":"","title":"Metode Monte Carlo"},{"location":"Metode%20Monte%20Carlo/#pengertian","text":"Metode Monte Carlo adalah algoritme komputasi untuk mensimulasikan berbagai perilaku sistem fisika dan matematika. Penggunaan klasik metode ini adalah untuk mengevaluasi integral definit , terutama integral multidimensi dengan syarat dan batasan yang rumit. Metode Monte Carlo sangat penting dalam fisika komputasi dan bidang terapan lainnya, dan memiliki aplikasi yang beragam mulai dari perhitungan kromodinamika kuantum esoterik hingga perancangan aerodinamika. Metode ini terbukti efisien dalam memecahkan persamaan diferensial integral medan radians, sehingga metode ini digunakan dalam perhitungan iluminasi global yang menghasilkan gambar-gambar fotorealistik model tiga dimensi, dimana diterapkan dalam video games , arsitektur , perancangan , film yang dihasilkan oleh komputer, efek-efek khusus dalam film, bisnis, ekonomi, dan bidang lainnya. (source:wikipedia) Karena algoritme ini memerlukan pengulangan (repetisi) dan perhitungan yang amat kompleks, metode Monte Carlo pada umumnya dilakukan menggunakan komputer, dan memakai berbagai teknik simulasi komputer. Algoritme Monte Carlo adalah metode Monte Carlo numerik yang digunakan untuk menemukan solusi problem matematis (yang dapat terdiri dari banyak variabel) yang susah dipecahkan, misalnya dengan kalkulus integral, atau metode numerik lainnya.","title":"Pengertian"},{"location":"Metode%20Monte%20Carlo/#jawaban-soal-nomor-3","text":"from scipy import random import numpy as np import matplotlib.pyplot as plt a = 0 b = 2 N = 2500 #function for integral def func ( x ): return ( 4 - x ** 2 ) ** 0.5 area = [] for i in range ( N ): xrand = np . zeros ( N ) for i in range ( len ( xrand )): xrand [ i ] = random . uniform ( a , b ) integral = 0.0 for i in range ( N ): integral += func ( xrand [ i ]) jawab = ( b - a ) / float ( N ) * integral area . append ( jawab ) plt . title ( \"Nilai phi\" ) plt . hist ( area , bins = 30 , ec = 'black' ) plt . xlabel ( \"Area\" ) plt . show () hasil running percobaan 1 Pada percobaan pertama Nilai Phi menunjukkan X=3.14465 y=255.824 hasil running percobaan 2 Pada percobaan kedua Nilai Phi menunjukkan x=3.14118 y=286.582","title":"Jawaban soal nomor 3"},{"location":"Metode%20Monte%20Carlo/#jawaban-soal-nomor-3_1","text":"from scipy import random #memanggil library random dari scipy import numpy as np #memanggil library numpy a = - 1 b = 1 N = 100 n = 3 xrand = np . zeros ( N ) #dx yrand = np . zeros ( N ) #dy zrand = np . zeros ( N ) #dz #fungsi np.zeros mengembalikan array baru dengan bentuk dari tipe yang diberikan, di mana nilai elemen sebagai 0. integral = 0.0 for i in range ( n + 1 ): for i in range ( len ( xrand )): xrand [ i ] = random . uniform ( a , b ) for i in range ( len ( yrand )): yrand [ i ] = random . uniform ( a , b ) for i in range ( len ( zrand )): zrand [ i ] = random . uniform ( a , b ) def func ( x , y , z ): return ( x ** 2 ) + ( y ** 2 ) + ( z ** 2 ) for i in range ( N ): integral += func ( xrand [ i ], yrand [ i ], zrand [ i ]) jwb = ( b - a ) / float ( N ) * integral print ( \"Hasil : \" , jwb ) #Percobaan 1 RESTART: C:\\Users\\hp\\AppData\\Local\\Programs\\Python\\Python37-32\\nomor3.py Hasil : 7.985285659898637 Process finished with exit code 0 #Percobaan 2 RESTART: C:\\Users\\hp\\AppData\\Local\\Programs\\Python\\Python37-32\\nomor3.py Hasil : 8.02539169028922 Process finished with exit code 0 Terima kasih . . . MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"Jawaban soal nomor 3"},{"location":"Metode%20Romberg/","text":"Metode Integrasi Romberg \u00b6 Pengertian \u00b6 Metode integrasi romberg didasarkan pada perluasan ekstrapolasi Richardson untuk memperoleh nilai integrasi yang semakin baik. Sebagai catatan , setiap penerapan ektrapolasi Richardson akan menaikan orde galat pada solusinya sebesar dua $$ O(h^2N)---menjadi --- O(h^{2N+2}) $$ Seperti halnya algoritma integrasi adaptif, integrasi Romberg adalah perluasan yang relatif mudah dari keluarga algoritma Newton-Cotes. Keduanya bekerja dengan menggunakan iterasi yang disempurnakan dari beberapa metode Newton-Cotes yang mendasarinya untuk memberikan perkiraan nilai integral yang lebih akurat. Tidak seperti proses komputasi fungsi riemann_adapint() , integrasi Romberg bukanlah pendekatan adaptif terhadap integrasi. Hal tersebut berarti metode Romberg tidak mengubah perilakunya sendiri berdasarkan perilaku fungsi yang akan diintegrasikan. Sebaliknya, kita mengeksploitasi perilaku fungsi trapesium pada batas untuk menghasilkan estimasi integral. Secara umum rumus integrasi dengan metode romberg adalah $$ \\begin{equation} I_{j,k}=\\frac{4^k I_{j,k-1}-I_{j-1,k-1}}{4^k-1} \\tag{9.21} \\end{equation} $$ Algoritma metode romberg \u00b6 Hasil code metode romberg \u00b6 import numpy as np def trapezcomp ( f , a , b , n ): \"\"\" Composite trapezoidal function integration INPUTS: f: the function to integrate a: lower bound of integration b: upper bound n: number of panels to create between ``a`` and ``b`` \"\"\" # Initialization h = ( b - a ) / n x = a # Composite rule In = f ( a ) for k in range ( 1 , n ): x = x + h In += 2 * f ( x ) return ( In + f ( b )) * h * 0.5 def romberg ( f , a , b , p ): \"\"\" Romberg integration INPUTS: f: the function to integrate a: lower bound of integration b: upper bound p: number of rows in the Romberg table \"\"\" I = np . zeros (( p , p )) for k in range ( 0 , p ): # Composite trapezoidal rule for 2^k panels I [ k , 0 ] = trapezcomp ( f , a , b , 2 ** k ) # Romberg recursive formula for j in range ( 0 , k ): I [ k , j + 1 ] = ( 4 ** ( j + 1 ) * I [ k , j ] - I [ k - 1 , j ]) / ( 4 ** ( j + 1 ) - 1 ) print ( I [ k , 0 : k + 1 ]) # display intermediate results return I if __name__ == '__main__' : def func ( x ): return np . sin ( x ) p_rows = 4 I = romberg ( func , 0 , np . pi / 2 , p_rows ) solution = I [ p_rows - 1 , p_rows - 1 ] print ( solution ) hasil code \u00b6 [0.78539816] [0.94805945 1.00227988] [0.9871158 1.00013458 0.99999157] [0.99678517 1.0000083 0.99999988 1.00000001] 1.0000000081440203 MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"Metode Romberg"},{"location":"Metode%20Romberg/#metode-integrasi-romberg","text":"","title":"Metode Integrasi Romberg"},{"location":"Metode%20Romberg/#pengertian","text":"Metode integrasi romberg didasarkan pada perluasan ekstrapolasi Richardson untuk memperoleh nilai integrasi yang semakin baik. Sebagai catatan , setiap penerapan ektrapolasi Richardson akan menaikan orde galat pada solusinya sebesar dua $$ O(h^2N)---menjadi --- O(h^{2N+2}) $$ Seperti halnya algoritma integrasi adaptif, integrasi Romberg adalah perluasan yang relatif mudah dari keluarga algoritma Newton-Cotes. Keduanya bekerja dengan menggunakan iterasi yang disempurnakan dari beberapa metode Newton-Cotes yang mendasarinya untuk memberikan perkiraan nilai integral yang lebih akurat. Tidak seperti proses komputasi fungsi riemann_adapint() , integrasi Romberg bukanlah pendekatan adaptif terhadap integrasi. Hal tersebut berarti metode Romberg tidak mengubah perilakunya sendiri berdasarkan perilaku fungsi yang akan diintegrasikan. Sebaliknya, kita mengeksploitasi perilaku fungsi trapesium pada batas untuk menghasilkan estimasi integral. Secara umum rumus integrasi dengan metode romberg adalah $$ \\begin{equation} I_{j,k}=\\frac{4^k I_{j,k-1}-I_{j-1,k-1}}{4^k-1} \\tag{9.21} \\end{equation} $$","title":"Pengertian"},{"location":"Metode%20Romberg/#algoritma-metode-romberg","text":"","title":"Algoritma metode romberg"},{"location":"Metode%20Romberg/#hasil-code-metode-romberg","text":"import numpy as np def trapezcomp ( f , a , b , n ): \"\"\" Composite trapezoidal function integration INPUTS: f: the function to integrate a: lower bound of integration b: upper bound n: number of panels to create between ``a`` and ``b`` \"\"\" # Initialization h = ( b - a ) / n x = a # Composite rule In = f ( a ) for k in range ( 1 , n ): x = x + h In += 2 * f ( x ) return ( In + f ( b )) * h * 0.5 def romberg ( f , a , b , p ): \"\"\" Romberg integration INPUTS: f: the function to integrate a: lower bound of integration b: upper bound p: number of rows in the Romberg table \"\"\" I = np . zeros (( p , p )) for k in range ( 0 , p ): # Composite trapezoidal rule for 2^k panels I [ k , 0 ] = trapezcomp ( f , a , b , 2 ** k ) # Romberg recursive formula for j in range ( 0 , k ): I [ k , j + 1 ] = ( 4 ** ( j + 1 ) * I [ k , j ] - I [ k - 1 , j ]) / ( 4 ** ( j + 1 ) - 1 ) print ( I [ k , 0 : k + 1 ]) # display intermediate results return I if __name__ == '__main__' : def func ( x ): return np . sin ( x ) p_rows = 4 I = romberg ( func , 0 , np . pi / 2 , p_rows ) solution = I [ p_rows - 1 , p_rows - 1 ] print ( solution )","title":"Hasil code metode romberg"},{"location":"Metode%20Romberg/#hasil-code","text":"[0.78539816] [0.94805945 1.00227988] [0.9871158 1.00013458 0.99999157] [0.99678517 1.0000083 0.99999988 1.00000001] 1.0000000081440203 MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"hasil code"},{"location":"Richardson/","text":"Ekstrapolasi Richardson \u00b6 Ekstrapolasi Richardson Dalam analisis numerik, ekstrapolasi Richardson adalah metode percepatan urutan, yang digunakan untuk meningkatkan laju konvergensi suatu urutan. Ekstrapolasi Richardson adalah salah satu teknik menggabungkan dua nilai perkiraan yang dihitung diperoleh dengan menggunakan rumus yang sama atau metode dengan dua ukuran langkah yang berbeda, untuk mendapatkan metode orde tinggi yang menyediakan lebih dekat perkiraan jumlah tertentu. Penerapan Ekstrapolasi Richardson dalam Python \u00b6 from math import * def Zero ( n , m ): Z = [] for i in range ( n ): Z . append ([ 0 ] * m ) return Z def D ( Func , a , h ): return ( Func ( a + h ) - Func ( a - h )) / ( 2 * h ) def ekstrapolasi_richardson ( func , a ): k = 9 L = Zero ( k , k ) for I in range ( k ): L [ I ][ 0 ] = D ( func , a , 1 / ( 2 ** ( I + 1 ))) for j in range ( 1 , k ): for i in range ( k - j ): L [ i ][ j ] = (( 4 ** ( j )) * L [ i + 1 ][ j - 1 ] - L [ i ][ j - 1 ]) / ( 4 ** ( j ) - 1 ) return L [ 0 ][ k - 1 ] print ( '===================== Richardson Extrapolation ======================' ) print ( 'soal : \\n f = -0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 dengan x = 0.5' ) print ( \"=======================================================================\" ) print ( ekstrapolasi_richardson ( lambda x : - 0.1 * x ** 4 - 0.15 * x ** 3 - 0.5 * x ** 2 - 0.25 * x + 1.2 , 0.5 )) print ( \"=======================================================================\" ) print ( 'diff(2**cos(pi+sin(x)) dengan x = pi/2 adalah = %04.20f ' % ekstrapolasi_richardson ( lambda x : 2 ** cos ( pi + sin ( x )), pi / 3 )) hasil running program diatas yaitu ===================== Richardson Extrapolation ====================== soal : f = -0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 dengan x = 0.5 ======================================================================= -0.9125000000000053 ======================================================================= diff(2**cos(pi+sin(x)) dengan x = pi/2 adalah = 0.16849558398154249050 MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"Richardson Extrapolation"},{"location":"Richardson/#ekstrapolasi-richardson","text":"Ekstrapolasi Richardson Dalam analisis numerik, ekstrapolasi Richardson adalah metode percepatan urutan, yang digunakan untuk meningkatkan laju konvergensi suatu urutan. Ekstrapolasi Richardson adalah salah satu teknik menggabungkan dua nilai perkiraan yang dihitung diperoleh dengan menggunakan rumus yang sama atau metode dengan dua ukuran langkah yang berbeda, untuk mendapatkan metode orde tinggi yang menyediakan lebih dekat perkiraan jumlah tertentu.","title":"Ekstrapolasi Richardson"},{"location":"Richardson/#penerapan-ekstrapolasi-richardson-dalam-python","text":"from math import * def Zero ( n , m ): Z = [] for i in range ( n ): Z . append ([ 0 ] * m ) return Z def D ( Func , a , h ): return ( Func ( a + h ) - Func ( a - h )) / ( 2 * h ) def ekstrapolasi_richardson ( func , a ): k = 9 L = Zero ( k , k ) for I in range ( k ): L [ I ][ 0 ] = D ( func , a , 1 / ( 2 ** ( I + 1 ))) for j in range ( 1 , k ): for i in range ( k - j ): L [ i ][ j ] = (( 4 ** ( j )) * L [ i + 1 ][ j - 1 ] - L [ i ][ j - 1 ]) / ( 4 ** ( j ) - 1 ) return L [ 0 ][ k - 1 ] print ( '===================== Richardson Extrapolation ======================' ) print ( 'soal : \\n f = -0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 dengan x = 0.5' ) print ( \"=======================================================================\" ) print ( ekstrapolasi_richardson ( lambda x : - 0.1 * x ** 4 - 0.15 * x ** 3 - 0.5 * x ** 2 - 0.25 * x + 1.2 , 0.5 )) print ( \"=======================================================================\" ) print ( 'diff(2**cos(pi+sin(x)) dengan x = pi/2 adalah = %04.20f ' % ekstrapolasi_richardson ( lambda x : 2 ** cos ( pi + sin ( x )), pi / 3 )) hasil running program diatas yaitu ===================== Richardson Extrapolation ====================== soal : f = -0.1*x**4-0.15*x**3-0.5*x**2-0.25*x+1.2 dengan x = 0.5 ======================================================================= -0.9125000000000053 ======================================================================= diff(2**cos(pi+sin(x)) dengan x = pi/2 adalah = 0.16849558398154249050 MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"Penerapan Ekstrapolasi Richardson dalam Python"},{"location":"pers_linier/","text":"Numerical Solution of System of Linear Algebraic Equations \u00b6 Eliminasi Gauss Jordan \u00b6 Eliminasi Gauss adalah suatu metode untuk mengoperasikan nilai-nilai di dalam matriks sehingga menjadi matriks yang lebih sederhana lagi. Dengan melakukan operasi baris sehingga matriks tersebut menjadi matriks yang baris. Ini dapat digunakan sebagai salah satu metode penyelesaian persamaan linear dengan menggunakan matriks. Caranya dengan mengubah persamaan linear tersebut ke dalam matriks teraugmentasi dan mengoperasikannya. Setelah menjadi matriks baris, lakukan substitusi balik untuk mendapatkan nilai dari variabel-variabel tersebut. Metode Eliminasi Gauss Jordan merupakan pengembangan metode eliminasi gauss, hanya saja augmented matrik , pada sebelah kiri dirubah menjadi matrik diagonal. Algoritma Gauss Jordan \u00b6 Listing Program \u00b6 import numpy as np #Definisi Matrix A = [] B = [] n = int ( input ( \"Masukkan ukuran Matrix: \" )) for i in range ( n ): baris = [] for i in range ( n ): a = int ( input ( \"Masukkan Nilai: \" )) baris . append ( a ) A . append ( baris ) for i in range ( n ): h = int ( input ( \"Masukkan Hasil: \" )) B . append ( h ) Matrix = np . array ( A , float ) Hasil = np . array ( B , float ) n = len ( Matrix ) #Eliminasi Gauss for k in range ( 0 , n - 1 ): for i in range ( k + 1 , n ): if Matrix [ i , k ] != 0 : lam = Matrix [ i , k ] / Matrix [ k , k ] Matrix [ i , k : n ] = Matrix [ i , k : n ] - ( Matrix [ k , k : n ] * lam ) Hasil [ i ] = Hasil [ i ] - ( Hasil [ k ] * lam ) print ( \"Matrix A : \" , ' \\n ' , Matrix ) #Subtitution x = np . zeros ( n , float ) for m in range ( n - 1 , - 1 , - 1 ): x [ m ] = ( Hasil [ m ] - np . dot ( Matrix [ m , m + 1 : n ], x [ m + 1 : n ])) / Matrix [ m , m ] print ( 'Nilai X ' , m + 1 , '=' , x [ m ]) Output: Masukkan ukuran Matrix: 3 Masukkan Nilai: 2 Masukkan Nilai: -2 Masukkan Nilai: 5 Masukkan Nilai: 1 Masukkan Nilai: 5 Masukkan Nilai: 2 Masukkan Nilai: 4 Masukkan Nilai: 5 Masukkan Nilai: 2 Masukkan Hasil: 12 Masukkan Hasil: 3 Masukkan Hasil: -4 Matrix A : [[ 2. -2. 5. ] [ 0. 6. -0.5 ] [ 0. 0. -7.25]] Nilai X 3 = 3.2413793103448274 Nilai X 2 = -0.2298850574712644 Nilai X 1 = -2.333333333333332 jadi panjang Matrix yang dibuat dalam Program Diatas adalah 3 variabel. |2 -2 5| |12| |1 5 2|=| 3 | |4 5 2| |-4| pivot yang dibentuk adalah a1.1,a2.2,dan a3.3 sehingga semua angka yang ada dibawah pivot akan dikonversikan menjadi nol sesuai hasil program dan hasil dari persamaan diatas menghasilkan x1=-2.333333333, x2=-0.22988505 dan x3=3.2413793 Eliminasi Gauss Jacobi \u00b6 Metode Iterasi Jacobi merupakan salah satu bidang analisis numerik yang digunakan untuk menyelesaikan permasalahan Persamaan Linier dan sering dijumpai dalam berbagai disiplin ilmu. Metode Iterasi Jacobi merupakan salah satu metode tak langsung, yaitu bermula dari suatu hampiran penyelesaian awal dan kemudian berusaha memperbaiki hampiran dalam tak berhingga namun langkah konvergen. Metode Iterasi Jacobi ini digunakan untuk menyelesaikan persamaan Linier berukuran besar dan proporsi koefisien nolnya besar. Metode ini ditemukan oleh Matematikawan yang berasal dari Jerman,Carl,Gustav,Jacobi. Penemuan ini diperkirakan pada tahun 1800-an. Listing Program \u00b6 from pprint import pprint from numpy import array , zeros , diag , diagflat , dot import numpy as np def jacobi ( A , b , N = 25 , x = None ): #Membuat iniial guess if x is None : x = zeros ( len ( A [ 0 ])) #Membuat vektor dari elemen matrix A D = diag ( A ) R = A - diagflat ( D ) #Iterasi for i in range ( N ): x = ( b - dot ( R , x )) / D return x Mat1 = [] Mat2 = [] n = int ( input ( \"Masukkan ukuran Matrix: \" )) for i in range ( n ): baris = [] for i in range ( n ): a = int ( input ( \"Masukkan Nilai: \" )) baris . append ( a ) Mat1 . append ( baris ) for i in range ( n ): h = int ( input ( \"Masukkan Hasil: \" )) Mat2 . append ( h ) A = array ( Mat1 , float ) b = array ( Mat2 , float ) x = len ( Mat1 ) guess = np . zeros ( x , float ) sol = jacobi ( A , b , N = 25 , x = guess ) print ( \"A:\" ) pprint ( A ) print ( \"b:\" ) pprint ( b ) print ( \"x:\" ) pprint ( sol ) Output: Masukkan ukuran Matrix: 3 Masukkan Nilai: 3 Masukkan Nilai: 1 Masukkan Nilai: -1 Masukkan Nilai: 4 Masukkan Nilai: 7 Masukkan Nilai: -3 Masukkan Nilai: 2 Masukkan Nilai: -2 Masukkan Nilai: 5 Masukkan Hasil: 5 Masukkan Hasil: 20 Masukkan Hasil: 10 A: array([[ 3., 1., -1.], [ 4., 7., -3.], [ 2., -2., 5.]]) b: array([ 5., 20., 10.]) x: array([1.50602413, 3.13253016, 2.6506024 ]) Program Gauss Seidel \u00b6 Listing Program \u00b6 def seidel ( a , x , b ): #Mencari Panjang Matrix n = len ( a ) for j in range ( 0 , n ): d = b [ j ] #Menghitung xi, yi, zi for i in range ( 0 , n ): if ( j != i ): d -= a [ j ][ i ] * x [ i ] x [ j ] = d / a [ j ][ j ] #Solusi return x m = int ( input ( \"Masukkan Panjang Matrix: \" )) a = [] b = [] for k in range ( m ): mat1 = [] for i in range ( m ): l = float ( input ( \"Masukkan a\" + str ( k + 1 ) + \",\" + str ( i + 1 ) + \": \" )) mat1 . append ( l ) h = float ( input ( \"Masukkan Hasil: \" )) b . append ( h ) a . append ( mat1 ) n = 3 x = [ 0 , 0 , 0 ] print ( x ) for i in range ( 0 , 100 ): x = seidel ( a , x , b ) print ( x ) Output: Masukkan Panjang Matrix: 3 Masukkan a1,1: 4 Masukkan a1,2: -1 Masukkan a1,3: 1 Masukkan Hasil: 7 Masukkan a2,1: 4 Masukkan a2,2: -8 Masukkan a2,3: 1 Masukkan Hasil: -21 Masukkan a3,1: -2 Masukkan a3,2: 1 Masukkan a3,3: 5 Masukkan Hasil: 15 [0, 0, 0] [1.75, 3.5, 3.0] [1.875, 3.9375, 2.9625] [1.99375, 3.9921875, 2.9990625] [1.99828125, 3.9990234375, 2.9995078125] [1.99987890625, 3.9998779296875, 2.9999759765625003] [1.99997548828125, 3.9999847412109375, 2.999993247070312] [1.9999978735351562, 3.9999980926513667, 2.999999530883789] [1.9999996404418945, 3.9999997615814205, 2.9999999038604734] [1.9999999644302369, 3.9999999701976776, 2.9999999917325595] [1.9999999946162794, 3.9999999962747097, 2.99999999859157] [1.9999999994207849, 3.9999999995343387, 2.9999999998614464] [1.9999999999182232, 3.999999999941793, 2.999999999978931] [1.9999999999907154, 3.999999999992724, 2.9999999999977414] [1.9999999999987457, 3.9999999999990905, 2.9999999999996803] [1.9999999999998526, 3.9999999999998863, 2.9999999999999636] [1.9999999999999807, 3.999999999999986, 2.999999999999995] [1.9999999999999978, 3.9999999999999987, 2.9999999999999996] [1.9999999999999996, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] Dari soal diatas persamaan yang dipilih adalah 4x-y+z=7, 4x-8y+z=-21 dan -2x+y+5z=15. Iterasi yang digunakan sebanyak 100 iterasi sehingga dapat menghasilkan x=2,y=4 dan z=3.","title":"Metode Numeric untuk Persamaan Linier"},{"location":"pers_linier/#numerical-solution-of-system-of-linear-algebraic-equations","text":"","title":"Numerical Solution of System of Linear Algebraic Equations"},{"location":"pers_linier/#eliminasi-gauss-jordan","text":"Eliminasi Gauss adalah suatu metode untuk mengoperasikan nilai-nilai di dalam matriks sehingga menjadi matriks yang lebih sederhana lagi. Dengan melakukan operasi baris sehingga matriks tersebut menjadi matriks yang baris. Ini dapat digunakan sebagai salah satu metode penyelesaian persamaan linear dengan menggunakan matriks. Caranya dengan mengubah persamaan linear tersebut ke dalam matriks teraugmentasi dan mengoperasikannya. Setelah menjadi matriks baris, lakukan substitusi balik untuk mendapatkan nilai dari variabel-variabel tersebut. Metode Eliminasi Gauss Jordan merupakan pengembangan metode eliminasi gauss, hanya saja augmented matrik , pada sebelah kiri dirubah menjadi matrik diagonal.","title":"Eliminasi Gauss Jordan"},{"location":"pers_linier/#algoritma-gauss-jordan","text":"","title":"Algoritma Gauss Jordan"},{"location":"pers_linier/#listing-program","text":"import numpy as np #Definisi Matrix A = [] B = [] n = int ( input ( \"Masukkan ukuran Matrix: \" )) for i in range ( n ): baris = [] for i in range ( n ): a = int ( input ( \"Masukkan Nilai: \" )) baris . append ( a ) A . append ( baris ) for i in range ( n ): h = int ( input ( \"Masukkan Hasil: \" )) B . append ( h ) Matrix = np . array ( A , float ) Hasil = np . array ( B , float ) n = len ( Matrix ) #Eliminasi Gauss for k in range ( 0 , n - 1 ): for i in range ( k + 1 , n ): if Matrix [ i , k ] != 0 : lam = Matrix [ i , k ] / Matrix [ k , k ] Matrix [ i , k : n ] = Matrix [ i , k : n ] - ( Matrix [ k , k : n ] * lam ) Hasil [ i ] = Hasil [ i ] - ( Hasil [ k ] * lam ) print ( \"Matrix A : \" , ' \\n ' , Matrix ) #Subtitution x = np . zeros ( n , float ) for m in range ( n - 1 , - 1 , - 1 ): x [ m ] = ( Hasil [ m ] - np . dot ( Matrix [ m , m + 1 : n ], x [ m + 1 : n ])) / Matrix [ m , m ] print ( 'Nilai X ' , m + 1 , '=' , x [ m ]) Output: Masukkan ukuran Matrix: 3 Masukkan Nilai: 2 Masukkan Nilai: -2 Masukkan Nilai: 5 Masukkan Nilai: 1 Masukkan Nilai: 5 Masukkan Nilai: 2 Masukkan Nilai: 4 Masukkan Nilai: 5 Masukkan Nilai: 2 Masukkan Hasil: 12 Masukkan Hasil: 3 Masukkan Hasil: -4 Matrix A : [[ 2. -2. 5. ] [ 0. 6. -0.5 ] [ 0. 0. -7.25]] Nilai X 3 = 3.2413793103448274 Nilai X 2 = -0.2298850574712644 Nilai X 1 = -2.333333333333332 jadi panjang Matrix yang dibuat dalam Program Diatas adalah 3 variabel. |2 -2 5| |12| |1 5 2|=| 3 | |4 5 2| |-4| pivot yang dibentuk adalah a1.1,a2.2,dan a3.3 sehingga semua angka yang ada dibawah pivot akan dikonversikan menjadi nol sesuai hasil program dan hasil dari persamaan diatas menghasilkan x1=-2.333333333, x2=-0.22988505 dan x3=3.2413793","title":"Listing Program"},{"location":"pers_linier/#eliminasi-gauss-jacobi","text":"Metode Iterasi Jacobi merupakan salah satu bidang analisis numerik yang digunakan untuk menyelesaikan permasalahan Persamaan Linier dan sering dijumpai dalam berbagai disiplin ilmu. Metode Iterasi Jacobi merupakan salah satu metode tak langsung, yaitu bermula dari suatu hampiran penyelesaian awal dan kemudian berusaha memperbaiki hampiran dalam tak berhingga namun langkah konvergen. Metode Iterasi Jacobi ini digunakan untuk menyelesaikan persamaan Linier berukuran besar dan proporsi koefisien nolnya besar. Metode ini ditemukan oleh Matematikawan yang berasal dari Jerman,Carl,Gustav,Jacobi. Penemuan ini diperkirakan pada tahun 1800-an.","title":"Eliminasi Gauss Jacobi"},{"location":"pers_linier/#listing-program_1","text":"from pprint import pprint from numpy import array , zeros , diag , diagflat , dot import numpy as np def jacobi ( A , b , N = 25 , x = None ): #Membuat iniial guess if x is None : x = zeros ( len ( A [ 0 ])) #Membuat vektor dari elemen matrix A D = diag ( A ) R = A - diagflat ( D ) #Iterasi for i in range ( N ): x = ( b - dot ( R , x )) / D return x Mat1 = [] Mat2 = [] n = int ( input ( \"Masukkan ukuran Matrix: \" )) for i in range ( n ): baris = [] for i in range ( n ): a = int ( input ( \"Masukkan Nilai: \" )) baris . append ( a ) Mat1 . append ( baris ) for i in range ( n ): h = int ( input ( \"Masukkan Hasil: \" )) Mat2 . append ( h ) A = array ( Mat1 , float ) b = array ( Mat2 , float ) x = len ( Mat1 ) guess = np . zeros ( x , float ) sol = jacobi ( A , b , N = 25 , x = guess ) print ( \"A:\" ) pprint ( A ) print ( \"b:\" ) pprint ( b ) print ( \"x:\" ) pprint ( sol ) Output: Masukkan ukuran Matrix: 3 Masukkan Nilai: 3 Masukkan Nilai: 1 Masukkan Nilai: -1 Masukkan Nilai: 4 Masukkan Nilai: 7 Masukkan Nilai: -3 Masukkan Nilai: 2 Masukkan Nilai: -2 Masukkan Nilai: 5 Masukkan Hasil: 5 Masukkan Hasil: 20 Masukkan Hasil: 10 A: array([[ 3., 1., -1.], [ 4., 7., -3.], [ 2., -2., 5.]]) b: array([ 5., 20., 10.]) x: array([1.50602413, 3.13253016, 2.6506024 ])","title":"Listing Program"},{"location":"pers_linier/#program-gauss-seidel","text":"","title":"Program Gauss Seidel"},{"location":"pers_linier/#listing-program_2","text":"def seidel ( a , x , b ): #Mencari Panjang Matrix n = len ( a ) for j in range ( 0 , n ): d = b [ j ] #Menghitung xi, yi, zi for i in range ( 0 , n ): if ( j != i ): d -= a [ j ][ i ] * x [ i ] x [ j ] = d / a [ j ][ j ] #Solusi return x m = int ( input ( \"Masukkan Panjang Matrix: \" )) a = [] b = [] for k in range ( m ): mat1 = [] for i in range ( m ): l = float ( input ( \"Masukkan a\" + str ( k + 1 ) + \",\" + str ( i + 1 ) + \": \" )) mat1 . append ( l ) h = float ( input ( \"Masukkan Hasil: \" )) b . append ( h ) a . append ( mat1 ) n = 3 x = [ 0 , 0 , 0 ] print ( x ) for i in range ( 0 , 100 ): x = seidel ( a , x , b ) print ( x ) Output: Masukkan Panjang Matrix: 3 Masukkan a1,1: 4 Masukkan a1,2: -1 Masukkan a1,3: 1 Masukkan Hasil: 7 Masukkan a2,1: 4 Masukkan a2,2: -8 Masukkan a2,3: 1 Masukkan Hasil: -21 Masukkan a3,1: -2 Masukkan a3,2: 1 Masukkan a3,3: 5 Masukkan Hasil: 15 [0, 0, 0] [1.75, 3.5, 3.0] [1.875, 3.9375, 2.9625] [1.99375, 3.9921875, 2.9990625] [1.99828125, 3.9990234375, 2.9995078125] [1.99987890625, 3.9998779296875, 2.9999759765625003] [1.99997548828125, 3.9999847412109375, 2.999993247070312] [1.9999978735351562, 3.9999980926513667, 2.999999530883789] [1.9999996404418945, 3.9999997615814205, 2.9999999038604734] [1.9999999644302369, 3.9999999701976776, 2.9999999917325595] [1.9999999946162794, 3.9999999962747097, 2.99999999859157] [1.9999999994207849, 3.9999999995343387, 2.9999999998614464] [1.9999999999182232, 3.999999999941793, 2.999999999978931] [1.9999999999907154, 3.999999999992724, 2.9999999999977414] [1.9999999999987457, 3.9999999999990905, 2.9999999999996803] [1.9999999999998526, 3.9999999999998863, 2.9999999999999636] [1.9999999999999807, 3.999999999999986, 2.999999999999995] [1.9999999999999978, 3.9999999999999987, 2.9999999999999996] [1.9999999999999996, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] [2.0, 4.0, 3.0] Dari soal diatas persamaan yang dipilih adalah 4x-y+z=7, 4x-8y+z=-21 dan -2x+y+5z=15. Iterasi yang digunakan sebanyak 100 iterasi sehingga dapat menghasilkan x=2,y=4 dan z=3.","title":"Listing Program"},{"location":"start/","text":"Identitas \u00b6 Yogi Widyanto 180411100049 Komputasi Numerik 4B MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"Identitas"},{"location":"start/#identitas","text":"Yogi Widyanto 180411100049 Komputasi Numerik 4B MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"Identitas"},{"location":"tugas_2/","text":"Numerical Solution of Algebraic and Transcendental Equation \u00b6 Metode Bisection \u00b6 Metode Bisection ini membagi range menjadi 2 bagian, dari dua bagian ini dipilih bagian mana yang mengandung akar sedangkan bagian yang tidak mengandung akar akan dibuang. Hal ini dilakukan berulang-ulang hingga diperoleh suatu akar persamaan. Algoritma metode bisection Definisikan fungsi f(x) yang akan dicari akarnya tentukan range atau nilai a dan b tentukan nilai toleransi dan iterasi maksimum hitung f(a) dan f(b) jika f(a)*f(b)>0 maka proses dihentikan karena tidak ada akar jika f(a)*f(b)<0 maka................. hitung nilai c $$ c =\\frac{(a+b)}{2} $$ hitung nilai f(c) Bila f(c).f(a)<0 maka b = c dan f(b)=f(c), bila tidak maka a=c dan f(a)=f(c) Jika |b-a|< e atau iterasi > iterasi maks maka proses dihentikan dan didapatkan akar x, bila tidak, ulangi langkah 6 Metode Regula Falsi \u00b6 Metode regula falsi adalah Metode pencarian akar persamaan dengan memanfaatkan kemiringan dan selisih tinggi dari dua titik batas range. Dua titik a dan b pada fungsi f(x) digunakan untuk mengestimasi posisi c dari akar interpolasi linier. Dikenal dengan metode False Position Metode ini juga merupakan penyempurna dari metode bisection Rumus c dari regula falsi : $$ c = a-f(a) \\frac{(b-a)}{f(b)-f(a)} $$ Algoritma metode regula falsi (benerin lagii) Definisikan fungsi f(x) yang akan dicari akarnya tentukan batas atas dan batas bawah tentukan nilai toleransi dan iterasi maksimum hitung f(a) dan f(b) jika f(a)*f(b)>0 maka proses dihentikan karena tidak ada akar jika f(a)*f(b)<0 maka................. hitung nilai c $$ c =\\frac{(a+b)}{2} $$ hitung nilai f(c) Bila f(c).f(a)<0 maka b = c dan f(b)=f(c), bila tidak maka a=c dan f(a)=f(c) Jika |b-a|< e atau iterasi > iterasi maks maka proses dihentikan dan didapatkan akar x, bila tidak, ulangi langkah 6 Metode Newton Raphson \u00b6 \u200b Dalam analisis numerik, metode Newton / Newton-Raphson yang mendapat nama dari Isaac Newton dan Joseph Rapshon, merupakan metode yang paling dikenal untuk mencari akar suatu fungsi f(x) dengan pendekatan satu titik dimana fungsi f(x) mempunyai turunan. Prosedur Metode Newton : menentukan x_0 sebagai titik awal, kemudian menarik garis lurus yang menyinggung titik f(x_0) . Hal ini berakibat garis I memotong sumbu x di titik x_1 Setelah itu diulangi langkah sebelumnya tapi sekarang x_1 dianggap sebagai titik awalnya. Dari mengulang langkah-langkah sebelumnya akan mendapatkan x_2 , x_3 , ... , x_n dengan x_n yang diperoleh adalah bilangan riil yang merupakan akar atau mendekati akar yang sebenarnya. persamaan garis I : y - y_0 = m(x - x_0) $$ y - f(x_0) = f'(x_0)(x - x_0) $$ x_1 perpotongan garis I dengan sumbu - x $$ 0 - f(x_0) = f'(x_0)(x - x_0) $$ y = 0 dan x = x_1 maka koordinat titik ( x_1 ,0) $$ - \\frac{f(x_0)}{f'(x_0)} = (x_1 - x_0) $$ sehingga di dapat sebuah rumus : $$ f'(x_n)=\\frac{f(x_n)-0}{f'(x_n)-{x_{n+1}}} $$ atau dapat diatur kembali menjadi : $$ x_1 = x_0 - \\frac{f(x_0)}{f'(x_0)} , x_2 = x_1 - \\frac{f(x_1)}{f'(x_1)}, ... , x_{n+1} = x_{n} - \\frac{f(x_{n})}{f'(x_{n})} $$ Metode Secant \u00b6 Metode Newton Raphson memerlukan perhitungan turunan fungsi f\u2019(x). Tidak semua fungsi mudah dicari turunannya terutama fungsi yang bentuknya rumit. Turunan fungsi dapat dihilangkan dengan cara menggantinya dengan bentuk lain yang ekivalen.Modifikasi metode Newton Raphson dinamakan metode Secant. Rumus Metode Secant $$ x_{r+1}=x_r-\\frac{f(x_r)(x_r - x_{r-1})}{f(x_r)-{x_{r+1}}} $$ Algoritma Metode Secant Definisikan f(x) Definisikan toleransi error e dan iterasi maksimum (n) Masukan dua nilai pendekatan awal yang diantaranya terdapat akar yaitu x0 dan x1 ,sebaiknya gunakan metode tabel untuk menjamin titik pendekatanya adalah titik pendekatan yang konvergensinya pada akar persamaan yang diharapkan. Hitung f(x0 ) dan f(x1) Untuk iterasi 1 s/d N : $$ x_{r+1}=x_r-\\frac{f(x_r)(x_r - x_{r-1})}{f(x_r)-{x_{r+1}}} $$ $$ Hitungf(x_{r+1}) $$ Implementasi \u00b6 Metode Bisection \u00b6 def bis ( a , b , n ): e = 0.001 fa = a ** 2 - 5 * a + 6 fb = b ** 2 - 5 * b + 6 if fa * fb < 0 : x = ( a + b ) / 2 fx = x ** 2 - 5 * x + 6 if fa * fx < 0 : b = x elif fx * fb < 0 : a = x if abs ( a - b ) < e : print ( \"Jumlah Iterasi : \" , n ) print ( x ) else : n += 1 print ( \"iterasi ke-\" + str ( n )) bis ( a , b , n ) else : if fa < fb : a -= 0.1 elif fb < fa : b += 0.1 bis ( a , b , n ) a = float ( input ( \"Masukkan nilai a : \" )) b = float ( input ( \"Masukkan nilai b : \" )) bis ( a , b , 0 ) Metode Regula Falsi \u00b6 def Regfal ( a , b , n ): e = 0.001 fa = a ** 2 - 5 * a + 6 fb = b ** 2 - 5 * b + 6 if fa * fb < 0 : n += 1 print ( \"iterasi ke-\" + str ( n )) x = (( a * abs ( fb )) + ( b * abs ( fa ))) / ( abs ( fa ) + abs ( fb )) fx = x ** 2 - 5 * x + 6 if fa * fx < 0 : b = x else : a = x if abs ( a - b ) < e : print ( x ) else : Regfal ( a , b , n ) else : if fa < fb : a -= 0.1 else : b += 0.1 Regfal ( a , b , n ) a = float ( input ( \"Masukkan interval a : \" )) b = float ( input ( \"Masukkan interval b : \" )) Regfal ( a , b , 0 ) Metode Newton Rapshon \u00b6 #Newton-Raphson x = float ( input ( \"Masukkan nilai awal x : \" )) n = 0 e = 0.001 while n >= 0 : print ( \"iterasi saat X\" + str ( n )) fx = x ** 2 - 5 * x + 6 fax = 2 * x - 5 x1 = x - ( fx / fax ) if abs ( x1 - x ) < e or n >= 100 : print ( \"Jumlah iterasi : \" , n + 1 ) print ( x ) break else : x = x1 n += 1 Metode Secant \u00b6 #Secant def Secant ( a , b , n ): e = 0.001 fa = a ** 2 - 5 * a + 6 fb = b ** 2 - 5 * b + 6 x = a - (( b - a ) / ( fb - fa )) * fa fx = x ** 2 - 5 * x + 6 n += 1 print ( \"iterasi ke-\" + str ( n )) if abs ( a - b ) < e : print ( \"Jumlah iterasi :\" , n ) print ( x ) else : a = b b = x Secant ( a , b , n ) a = float ( input ( \"Masukkan nilai a : \" )) b = float ( input ( \"Masukkan nilai b : \" )) n = 0 Secant ( a , b , 0 ) MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"Mencari Akar Persamaan"},{"location":"tugas_2/#numerical-solution-of-algebraic-and-transcendental-equation","text":"","title":"Numerical Solution of Algebraic and Transcendental Equation"},{"location":"tugas_2/#metode-bisection","text":"Metode Bisection ini membagi range menjadi 2 bagian, dari dua bagian ini dipilih bagian mana yang mengandung akar sedangkan bagian yang tidak mengandung akar akan dibuang. Hal ini dilakukan berulang-ulang hingga diperoleh suatu akar persamaan. Algoritma metode bisection Definisikan fungsi f(x) yang akan dicari akarnya tentukan range atau nilai a dan b tentukan nilai toleransi dan iterasi maksimum hitung f(a) dan f(b) jika f(a)*f(b)>0 maka proses dihentikan karena tidak ada akar jika f(a)*f(b)<0 maka................. hitung nilai c $$ c =\\frac{(a+b)}{2} $$ hitung nilai f(c) Bila f(c).f(a)<0 maka b = c dan f(b)=f(c), bila tidak maka a=c dan f(a)=f(c) Jika |b-a|< e atau iterasi > iterasi maks maka proses dihentikan dan didapatkan akar x, bila tidak, ulangi langkah 6","title":"Metode Bisection"},{"location":"tugas_2/#metode-regula-falsi","text":"Metode regula falsi adalah Metode pencarian akar persamaan dengan memanfaatkan kemiringan dan selisih tinggi dari dua titik batas range. Dua titik a dan b pada fungsi f(x) digunakan untuk mengestimasi posisi c dari akar interpolasi linier. Dikenal dengan metode False Position Metode ini juga merupakan penyempurna dari metode bisection Rumus c dari regula falsi : $$ c = a-f(a) \\frac{(b-a)}{f(b)-f(a)} $$ Algoritma metode regula falsi (benerin lagii) Definisikan fungsi f(x) yang akan dicari akarnya tentukan batas atas dan batas bawah tentukan nilai toleransi dan iterasi maksimum hitung f(a) dan f(b) jika f(a)*f(b)>0 maka proses dihentikan karena tidak ada akar jika f(a)*f(b)<0 maka................. hitung nilai c $$ c =\\frac{(a+b)}{2} $$ hitung nilai f(c) Bila f(c).f(a)<0 maka b = c dan f(b)=f(c), bila tidak maka a=c dan f(a)=f(c) Jika |b-a|< e atau iterasi > iterasi maks maka proses dihentikan dan didapatkan akar x, bila tidak, ulangi langkah 6","title":"Metode Regula Falsi"},{"location":"tugas_2/#metode-newton-raphson","text":"\u200b Dalam analisis numerik, metode Newton / Newton-Raphson yang mendapat nama dari Isaac Newton dan Joseph Rapshon, merupakan metode yang paling dikenal untuk mencari akar suatu fungsi f(x) dengan pendekatan satu titik dimana fungsi f(x) mempunyai turunan. Prosedur Metode Newton : menentukan x_0 sebagai titik awal, kemudian menarik garis lurus yang menyinggung titik f(x_0) . Hal ini berakibat garis I memotong sumbu x di titik x_1 Setelah itu diulangi langkah sebelumnya tapi sekarang x_1 dianggap sebagai titik awalnya. Dari mengulang langkah-langkah sebelumnya akan mendapatkan x_2 , x_3 , ... , x_n dengan x_n yang diperoleh adalah bilangan riil yang merupakan akar atau mendekati akar yang sebenarnya. persamaan garis I : y - y_0 = m(x - x_0) $$ y - f(x_0) = f'(x_0)(x - x_0) $$ x_1 perpotongan garis I dengan sumbu - x $$ 0 - f(x_0) = f'(x_0)(x - x_0) $$ y = 0 dan x = x_1 maka koordinat titik ( x_1 ,0) $$ - \\frac{f(x_0)}{f'(x_0)} = (x_1 - x_0) $$ sehingga di dapat sebuah rumus : $$ f'(x_n)=\\frac{f(x_n)-0}{f'(x_n)-{x_{n+1}}} $$ atau dapat diatur kembali menjadi : $$ x_1 = x_0 - \\frac{f(x_0)}{f'(x_0)} , x_2 = x_1 - \\frac{f(x_1)}{f'(x_1)}, ... , x_{n+1} = x_{n} - \\frac{f(x_{n})}{f'(x_{n})} $$","title":"Metode Newton Raphson"},{"location":"tugas_2/#metode-secant","text":"Metode Newton Raphson memerlukan perhitungan turunan fungsi f\u2019(x). Tidak semua fungsi mudah dicari turunannya terutama fungsi yang bentuknya rumit. Turunan fungsi dapat dihilangkan dengan cara menggantinya dengan bentuk lain yang ekivalen.Modifikasi metode Newton Raphson dinamakan metode Secant. Rumus Metode Secant $$ x_{r+1}=x_r-\\frac{f(x_r)(x_r - x_{r-1})}{f(x_r)-{x_{r+1}}} $$ Algoritma Metode Secant Definisikan f(x) Definisikan toleransi error e dan iterasi maksimum (n) Masukan dua nilai pendekatan awal yang diantaranya terdapat akar yaitu x0 dan x1 ,sebaiknya gunakan metode tabel untuk menjamin titik pendekatanya adalah titik pendekatan yang konvergensinya pada akar persamaan yang diharapkan. Hitung f(x0 ) dan f(x1) Untuk iterasi 1 s/d N : $$ x_{r+1}=x_r-\\frac{f(x_r)(x_r - x_{r-1})}{f(x_r)-{x_{r+1}}} $$ $$ Hitungf(x_{r+1}) $$","title":"Metode Secant"},{"location":"tugas_2/#implementasi","text":"","title":"Implementasi"},{"location":"tugas_2/#metode-bisection_1","text":"def bis ( a , b , n ): e = 0.001 fa = a ** 2 - 5 * a + 6 fb = b ** 2 - 5 * b + 6 if fa * fb < 0 : x = ( a + b ) / 2 fx = x ** 2 - 5 * x + 6 if fa * fx < 0 : b = x elif fx * fb < 0 : a = x if abs ( a - b ) < e : print ( \"Jumlah Iterasi : \" , n ) print ( x ) else : n += 1 print ( \"iterasi ke-\" + str ( n )) bis ( a , b , n ) else : if fa < fb : a -= 0.1 elif fb < fa : b += 0.1 bis ( a , b , n ) a = float ( input ( \"Masukkan nilai a : \" )) b = float ( input ( \"Masukkan nilai b : \" )) bis ( a , b , 0 )","title":"Metode Bisection"},{"location":"tugas_2/#metode-regula-falsi_1","text":"def Regfal ( a , b , n ): e = 0.001 fa = a ** 2 - 5 * a + 6 fb = b ** 2 - 5 * b + 6 if fa * fb < 0 : n += 1 print ( \"iterasi ke-\" + str ( n )) x = (( a * abs ( fb )) + ( b * abs ( fa ))) / ( abs ( fa ) + abs ( fb )) fx = x ** 2 - 5 * x + 6 if fa * fx < 0 : b = x else : a = x if abs ( a - b ) < e : print ( x ) else : Regfal ( a , b , n ) else : if fa < fb : a -= 0.1 else : b += 0.1 Regfal ( a , b , n ) a = float ( input ( \"Masukkan interval a : \" )) b = float ( input ( \"Masukkan interval b : \" )) Regfal ( a , b , 0 )","title":"Metode Regula Falsi"},{"location":"tugas_2/#metode-newton-rapshon","text":"#Newton-Raphson x = float ( input ( \"Masukkan nilai awal x : \" )) n = 0 e = 0.001 while n >= 0 : print ( \"iterasi saat X\" + str ( n )) fx = x ** 2 - 5 * x + 6 fax = 2 * x - 5 x1 = x - ( fx / fax ) if abs ( x1 - x ) < e or n >= 100 : print ( \"Jumlah iterasi : \" , n + 1 ) print ( x ) break else : x = x1 n += 1","title":"Metode Newton Rapshon"},{"location":"tugas_2/#metode-secant_1","text":"#Secant def Secant ( a , b , n ): e = 0.001 fa = a ** 2 - 5 * a + 6 fb = b ** 2 - 5 * b + 6 x = a - (( b - a ) / ( fb - fa )) * fa fx = x ** 2 - 5 * x + 6 n += 1 print ( \"iterasi ke-\" + str ( n )) if abs ( a - b ) < e : print ( \"Jumlah iterasi :\" , n ) print ( x ) else : a = b b = x Secant ( a , b , n ) a = float ( input ( \"Masukkan nilai a : \" )) b = float ( input ( \"Masukkan nilai b : \" )) n = 0 Secant ( a , b , 0 ) MathJax.Hub.Config({ tex2jax: {inlineMath: [['$$','$$']]} });","title":"Metode Secant"}]}